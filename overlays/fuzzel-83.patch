From 62629933c277f92faee63c5791a0b7b0404db882 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 15:58:24 +0100
Subject: [PATCH 01/23] wayland: repair debug log (variables have been renamed)

---
 wayland.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/wayland.c b/wayland.c
index 84cedfc..6100e06 100644
--- a/wayland.c
+++ b/wayland.c
@@ -905,8 +905,8 @@ reload_font(struct wayland *wayl, float new_dpi, unsigned new_scale)
     LOG_DBG(
         "font reload: scale: %u -> %u, dpi: %.2f -> %.2f size method: %s -> %s",
         wayl->scale, new_scale, wayl->dpi, new_dpi,
-        was_scaled_using_dpi ? "DPI" : "scaling factor",
-        will_scale_using_dpi ? "DPI" : "scaling factor");
+        was_sized_using_dpi ? "DPI" : "scaling factor",
+        will_size_using_dpi ? "DPI" : "scaling factor");
 
     wayl->font_is_sized_by_dpi = will_size_using_dpi;
 
-- 
2.30.2


From 1855b0e500fc54fbfe408082d1e2b689e1dab3cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 15:58:50 +0100
Subject: [PATCH 02/23] wayland: debug log on keyboard enter event

---
 wayland.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/wayland.c b/wayland.c
index 6100e06..443eb39 100644
--- a/wayland.c
+++ b/wayland.c
@@ -416,6 +416,8 @@ keyboard_enter(void *data, struct wl_keyboard *wl_keyboard, uint32_t serial,
 {
     struct seat *seat = data;
     seat->kbd.serial = serial;
+
+    LOG_DBG("keyboard enter");
 #if 0
     uint32_t *key;
     wl_array_for_each(key, keys)
-- 
2.30.2


From 92a87304440f3be5c742240128dfaf604e523dd6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 15:59:41 +0100
Subject: [PATCH 03/23] main: populate application list in a thread

Display the surface as soon as possible, to reduce the latency between
application startup and when we can start receive input.

The operation that takes the most time, by far, is when we populate
the application list, since this involves a lot of disk I/O.

Do this in a thread. When done, the thread signals this through an
event FD. The FDM handler for the event fd updates the matches object
and refreshes the GUI.

Closes #82
---
 main.c      | 143 ++++++++++++++++++++++++++++++++++++++++++++++------
 match.c     |  33 +++++++++---
 match.h     |   6 ++-
 meson.build |   2 +
 4 files changed, 160 insertions(+), 24 deletions(-)

diff --git a/main.c b/main.c
index 99bbfda..5d23b78 100644
--- a/main.c
+++ b/main.c
@@ -4,6 +4,7 @@
 #include <string.h>
 #include <getopt.h>
 #include <errno.h>
+#include <threads.h>
 
 #include <locale.h>
 
@@ -11,6 +12,8 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/file.h>
+#include <sys/eventfd.h>
+#include <sys/epoll.h>
 #include <fcntl.h>
 #include <dirent.h>
 
@@ -313,6 +316,66 @@ acquire_file_lock(const char *path, int *fd)
     return true;
 }
 
+struct populate_apps_context {
+    struct application_list *apps;
+    const char *terminal;
+    bool actions_enabled;
+    bool dmenu_mode;
+    int event_fd;
+};
+
+/* THREAD */
+static int
+populate_apps(void *_ctx)
+{
+    struct populate_apps_context *ctx = _ctx;
+    struct application_list *apps = ctx->apps;
+    const char *terminal = ctx->terminal;
+    bool actions_enabled = ctx->actions_enabled;
+    bool dmenu_mode = ctx->dmenu_mode;
+
+    LOG_DBG("populate application list: start");
+
+    if (dmenu_mode)
+        dmenu_load_entries(apps);
+    else
+        xdg_find_programs(terminal, actions_enabled, apps);
+    read_cache(apps);
+
+    LOG_DBG("populate application list: done");
+
+    ssize_t bytes = write(ctx->event_fd, &(uint64_t){1}, sizeof(uint64_t));
+    return !(bytes == (ssize_t)sizeof(uint64_t));
+}
+
+struct fdm_data {
+    struct wayland *wayl;
+    struct application_list *apps;
+    struct matches *matches;
+    struct prompt *prompt;
+};
+
+/*
+ * Called when the application list has been populated
+ */
+static bool
+fdm_apps_populated(struct fdm *fdm, int fd, int events, void *_data)
+{
+    struct fdm_data *data = _data;
+    struct wayland *wayl = data->wayl;
+    struct application_list *apps = data->apps;
+    struct matches *matches = data->matches;
+    struct prompt *prompt = data->prompt;
+
+    /* Update matches list, then refresh the GUI */
+    matches_set_applications(matches, apps);
+    matches_update(matches, prompt);
+    wayl_refresh(wayl);
+
+    fdm_del_no_close(fdm, fd);
+    return true;
+}
+
 int
 main(int argc, char *const *argv)
 {
@@ -714,6 +777,8 @@ main(int argc, char *const *argv)
     struct matches *matches = NULL;
     struct render *render = NULL;
     struct wayland *wayl = NULL;
+    thrd_t app_thread_id = -1;
+    int event_fd = -1;
 
     char *lock_file = NULL;
     int file_lock_fd = -1;
@@ -738,18 +803,6 @@ main(int argc, char *const *argv)
     if ((fdm = fdm_init()) == NULL)
         goto out;
 
-
-    /* Load applications */
-    if ((apps = applications_init()) == NULL)
-        goto out;
-    if (dmenu_mode) {
-        dmenu_load_entries(apps);
-        if (no_run_if_empty && apps->count == 0)
-            goto out;
-    } else
-        xdg_find_programs(terminal, actions_enabled, apps);
-    read_cache(apps);
-
     if ((render = render_init(&render_options)) == NULL)
         goto out;
 
@@ -757,9 +810,26 @@ main(int argc, char *const *argv)
         goto out;
 
     if ((matches = matches_init(
-             apps, match_fields, fuzzy, fuzzy_min_length,
+             match_fields, fuzzy, fuzzy_min_length,
              fuzzy_max_length_discrepancy, fuzzy_max_distance)) == NULL)
         goto out;
+    matches_max_matches_per_page_set(matches, render_options.lines);
+
+    if ((apps = applications_init()) == NULL)
+        goto out;
+
+    if (dmenu_mode && no_run_if_empty) {
+        /*
+         * If no_run_if_empty is set, we *must* load the entries
+         * *before displaying the window.
+         */
+        dmenu_load_entries(apps);
+        if (apps->count == 0)
+            goto out;
+
+        matches_set_applications(matches, apps);
+        matches_update(matches, prompt);
+    }
 
     struct font_reload_context font_reloaded_data = {
         .icons_enabled = icons_enabled,
@@ -772,11 +842,43 @@ main(int argc, char *const *argv)
              dmenu_mode, launch_prefix, output_name, font_name, dpi_aware,
              &font_reloaded, &font_reloaded_data)) == NULL)
         goto out;
-
-    matches_max_matches_per_page_set(matches, render_options.lines);
-    matches_update(matches, prompt);
     wayl_refresh(wayl);
 
+    struct populate_apps_context populate_apps_context = {
+        .apps = apps,
+        .terminal = terminal,
+        .actions_enabled = actions_enabled,
+        .dmenu_mode = dmenu_mode,
+        .event_fd = -1,
+    };
+
+    struct fdm_data fdm_data = {
+        .wayl = wayl,
+        .apps = apps,
+        .matches = matches,
+        .prompt = prompt,
+    };
+
+    /* Create thread that will populate the application list */
+    if (!dmenu_mode || !no_run_if_empty) {
+        event_fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+        if (event_fd < 0) {
+            LOG_ERRNO("failed to create event FD");
+            goto out;
+        }
+
+        populate_apps_context.event_fd = event_fd;
+
+        if (thrd_create(&app_thread_id, &populate_apps,
+                        &populate_apps_context) != thrd_success)
+        {
+            LOG_ERR("failed to create thread");
+            goto out;
+        }
+        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &fdm_data))
+            goto out;
+    }
+
     while (true) {
         wayl_flush(wayl);
         if (!fdm_poll(fdm))
@@ -789,6 +891,15 @@ main(int argc, char *const *argv)
     ret = wayl_exit_code(wayl);
 
 out:
+    if (app_thread_id != (thrd_t)-1) {
+        int res;
+        thrd_join(app_thread_id, &res);
+        LOG_WARN("populate app thread return value: %d", res);
+    }
+
+    if (event_fd >= 0)
+        close(event_fd);
+
     shm_fini();
 
     wayl_destroy(wayl);
diff --git a/match.c b/match.c
index 4ec6b6d..24776c6 100644
--- a/match.c
+++ b/match.c
@@ -160,15 +160,15 @@ match_levenshtein(struct matches *matches,
 }
 
 struct matches *
-matches_init(const struct application_list *applications,
+matches_init(/*const struct application_list *applications,*/
              enum match_fields fields, bool fuzzy, size_t fuzzy_min_length,
              size_t fuzzy_max_length_discrepancy, size_t fuzzy_max_distance)
 {
     struct matches *matches = malloc(sizeof(*matches));
     *matches = (struct matches) {
-        .applications = applications,
+        .applications = NULL,
         .fields = fields,
-        .matches = malloc(applications->count * sizeof(matches->matches[0])),
+        .matches = NULL, //malloc(applications->count * sizeof(matches->matches[0])),
         .fuzzy = fuzzy,
         .page_count = 0,
         .match_count = 0,
@@ -191,6 +191,18 @@ matches_destroy(struct matches *matches)
     free(matches);
 }
 
+void
+matches_set_applications(struct matches *matches,
+                         const struct application_list *applications)
+{
+    assert(matches->applications == NULL);
+    assert(matches->matches == NULL);
+
+    matches->applications = applications;
+    matches->matches = malloc(
+        applications->count * sizeof(matches->matches[0]));
+}
+
 size_t
 matches_max_matches_per_page(const struct matches *matches)
 {
@@ -206,13 +218,17 @@ matches_max_matches_per_page_set(struct matches *matches, size_t max_matches)
 size_t
 matches_get_page_count(const struct matches *matches)
 {
-    return matches->match_count / matches->max_matches_per_page;
+    return matches->max_matches_per_page != 0
+        ? matches->match_count / matches->max_matches_per_page
+        : 0;
 }
 
 size_t
 matches_get_page(const struct matches *matches)
 {
-    return matches->selected / matches->max_matches_per_page;
+    return matches->max_matches_per_page != 0
+        ? matches->selected / matches->max_matches_per_page
+        : 0;
 }
 
 const struct match *
@@ -260,7 +276,9 @@ matches_get_count(const struct matches *matches)
 size_t
 matches_get_match_index(const struct matches *matches)
 {
-    return matches->selected % matches->max_matches_per_page;
+    return matches->max_matches_per_page != 0
+        ? matches->selected % matches->max_matches_per_page
+        : 0;
 }
 
 bool
@@ -385,6 +403,9 @@ matches_update(struct matches *matches, const struct prompt *prompt)
 {
     assert(matches->max_matches_per_page > 0);
 
+    if (matches->applications == NULL)
+        return;
+
     const wchar_t *ptext = prompt_text(prompt);
 
     /* Nothing entered; all programs found matches */
diff --git a/match.h b/match.h
index e73d3eb..9cca376 100644
--- a/match.h
+++ b/match.h
@@ -29,13 +29,15 @@ enum match_fields {
 };
 
 struct matches;
-struct matches *matches_init(const struct application_list *applications,
-                             enum match_fields fields, bool fuzzy,
+struct matches *matches_init(enum match_fields fields, bool fuzzy,
                              size_t fuzzy_min_length,
                              size_t fuzzy_max_length_discrepancy,
                              size_t fuzzy_max_distance);
 void matches_destroy(struct matches *matches);
 
+void matches_set_applications(
+    struct matches *matches, const struct application_list *applications);
+
 size_t matches_max_matches_per_page(const struct matches *matches);
 void matches_max_matches_per_page_set(
     struct matches *matches, size_t max_matches);
diff --git a/meson.build b/meson.build
index 6b41b58..718ce24 100644
--- a/meson.build
+++ b/meson.build
@@ -51,6 +51,7 @@ if cc.has_argument('-fmacro-prefix-map=/foo=')
 endif
 
 math = cc.find_library('m')
+threads = [dependency('threads'), cc.find_library('stdthreads', required: false)]
 fontconfig = dependency('fontconfig')
 pixman = dependency('pixman-1')
 cairo = dependency('cairo', required: get_option('enable-cairo'))
@@ -146,6 +147,7 @@ executable(
   'xdg.c', 'xdg.h',
   wl_proto_src + wl_proto_headers, version,
   dependencies: [math,
+                 threads,
                  pixman,
                  fontconfig,
                  cairo,
-- 
2.30.2


From 393b8fb6d1f9f818f095720855ea3d9054288d42 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 16:03:29 +0100
Subject: [PATCH 04/23] changelog: appplication list is now populated in a
 thread

---
 CHANGELOG.md | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index a117197..bd40091 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -48,6 +48,9 @@
 * Use a lock file instead of parsing `/proc` to prevent multiple
   fuzzel instances from running at the same time
   (https://codeberg.org/dnkl/fuzzel/issues/84).
+* The application list is now populated in a separate thread, in
+  parallel to initializing the GUI. This reduces the risk of missing
+  keyboard input (https://codeberg.org/dnkl/fuzzel/issues/82).
 
 
 ### Deprecated
-- 
2.30.2


From a460fd4bc9b5a7fdac500250b82d88bc56426117 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 16:16:00 +0100
Subject: [PATCH 05/23] =?UTF-8?q?main:=20proper=20logging=20of=20failures?=
 =?UTF-8?q?=20in=20the=20=E2=80=9Cpopulate=20app=20list=E2=80=9D=20thread?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 main.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/main.c b/main.c
index 5d23b78..9ab452e 100644
--- a/main.c
+++ b/main.c
@@ -345,7 +345,11 @@ populate_apps(void *_ctx)
     LOG_DBG("populate application list: done");
 
     ssize_t bytes = write(ctx->event_fd, &(uint64_t){1}, sizeof(uint64_t));
-    return !(bytes == (ssize_t)sizeof(uint64_t));
+    if (bytes < 0)
+        return -errno;
+    else if (bytes != (ssize_t)sizeof(uint64_t))
+        return 1;
+    return 0;
 }
 
 struct fdm_data {
@@ -894,7 +898,14 @@ out:
     if (app_thread_id != (thrd_t)-1) {
         int res;
         thrd_join(app_thread_id, &res);
-        LOG_WARN("populate app thread return value: %d", res);
+
+        if (res != 0) {
+            if (res < 0)
+                LOG_ERRNO_P("populate application list thread failed", res);
+            else
+                LOG_ERRNO("populate application list thread failed: "
+                          "failed to signal done event");
+        }
     }
 
     if (event_fd >= 0)
-- 
2.30.2


From d3c7613dc4ea3c160dd9f4bac351b64b6be40960 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 16:19:31 +0100
Subject: [PATCH 06/23] main: thrd_t is an implementation specific type

It can be either a pointer, or an integer (and is).
---
 main.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/main.c b/main.c
index 9ab452e..3692c2c 100644
--- a/main.c
+++ b/main.c
@@ -781,7 +781,9 @@ main(int argc, char *const *argv)
     struct matches *matches = NULL;
     struct render *render = NULL;
     struct wayland *wayl = NULL;
-    thrd_t app_thread_id = -1;
+
+    thrd_t app_thread_id;
+    bool join_thread = false;
     int event_fd = -1;
 
     char *lock_file = NULL;
@@ -879,6 +881,8 @@ main(int argc, char *const *argv)
             LOG_ERR("failed to create thread");
             goto out;
         }
+        join_thread = true;
+
         if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &fdm_data))
             goto out;
     }
@@ -895,7 +899,7 @@ main(int argc, char *const *argv)
     ret = wayl_exit_code(wayl);
 
 out:
-    if (app_thread_id != (thrd_t)-1) {
+    if (join_thread) {
         int res;
         thrd_join(app_thread_id, &res);
 
-- 
2.30.2


From bcffae690f799487728adb42901b9e5c952f68e2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 21:33:53 +0100
Subject: [PATCH 07/23] main: load icon themes, and icons, in a thread
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

First, this commit replaces all custom ‘context’ struct with a single,
super-context struct that contains everything needed by all callbacks.

Then, the icon loading logic is rewritten:

* Themes are loaded in the application populating thread, and only in
  non-dmenu mode

* Icons are also loaded in the application population thread, **if**
  we have an icon size (which we do after the wayland backend has called
  our font-reloaded callback at least once.)

Since we _also_ need to reload the icons in the font-reloaded
callback (when we guess wrong about which output we’ll get mapped on),
the icon reloading must be done in a critical section. If not, the
following could happen:

* The application population thread is started
* Wayland instantiates the font, and calls our font-reloaded cb
* The font-reloaded cb sets our context’s icon-size member
* The application population thread starts loading the icons
* Our window is finally mapped, but on an output whose DPI doesn’t
  matched the currently loaded font’s. The Wayland backed reloads the
  font and calls our cb
* Our cb reloads the icons **in parallel with the application
  population thread**

Chaos ensues.
---
 main.c    | 185 ++++++++++++++++++++++++++++++------------------------
 wayland.h |   1 +
 2 files changed, 105 insertions(+), 81 deletions(-)

diff --git a/main.c b/main.c
index 3692c2c..aec886f 100644
--- a/main.c
+++ b/main.c
@@ -33,6 +33,28 @@
 #include "wayland.h"
 #include "xdg.h"
 
+struct context {
+    struct wayland *wayl;
+    struct render *render;
+    struct matches *matches;
+    struct prompt *prompt;
+    struct application_list *apps;
+
+    icon_theme_list_t *themes;
+    int icon_size;
+    mtx_t *icon_lock;
+
+    struct {
+        const char *icon_theme;
+        const char *terminal;
+        bool icons_enabled;
+        bool actions_enabled;
+        bool dmenu_mode;
+    } options;
+
+    int apps_loaded_fd;
+};
+
 static struct rgba
 hex_to_rgba(uint32_t color)
 {
@@ -226,19 +248,23 @@ print_usage(const char *prog_name)
     printf("All colors are RGBA - i.e. 8-digit hex values, without prefix.\n");
 }
 
-struct font_reload_context {
-    bool icons_enabled;
-    const icon_theme_list_t *themes;
-    struct application_list *apps;
-};
-
 static void
 font_reloaded(struct wayland *wayl, struct fcft_font *font, void *data)
 {
-    struct font_reload_context *ctx = data;
-    if (ctx->icons_enabled)
-        icon_reload_application_icons(*ctx->themes, font->height, ctx->apps);
+    struct context *ctx = data;
+
     applications_flush_text_run_cache(ctx->apps);
+
+    mtx_lock(ctx->icon_lock);
+    {
+        ctx->icon_size = font->height;
+
+        if (ctx->options.icons_enabled) {
+            icon_reload_application_icons(
+                *ctx->themes, ctx->icon_size, ctx->apps);
+        }
+    }
+    mtx_unlock(ctx->icon_lock);
 }
 
 static bool
@@ -316,35 +342,43 @@ acquire_file_lock(const char *path, int *fd)
     return true;
 }
 
-struct populate_apps_context {
-    struct application_list *apps;
-    const char *terminal;
-    bool actions_enabled;
-    bool dmenu_mode;
-    int event_fd;
-};
-
 /* THREAD */
 static int
 populate_apps(void *_ctx)
 {
-    struct populate_apps_context *ctx = _ctx;
+    struct context *ctx = _ctx;
     struct application_list *apps = ctx->apps;
-    const char *terminal = ctx->terminal;
-    bool actions_enabled = ctx->actions_enabled;
-    bool dmenu_mode = ctx->dmenu_mode;
-
-    LOG_DBG("populate application list: start");
+    const char *icon_theme = ctx->options.icon_theme;
+    const char *terminal = ctx->options.terminal;
+    bool actions_enabled = ctx->options.actions_enabled;
+    bool dmenu_mode = ctx->options.dmenu_mode;
+    bool icons_enabled = ctx->options.icons_enabled;
 
     if (dmenu_mode)
         dmenu_load_entries(apps);
-    else
+
+    else {
         xdg_find_programs(terminal, actions_enabled, apps);
-    read_cache(apps);
 
-    LOG_DBG("populate application list: done");
+        if (icons_enabled) {
+            *ctx->themes = icon_load_theme(icon_theme);
+            if (tll_length(*ctx->themes) > 0)
+                LOG_INFO("theme: %s", tll_front(*ctx->themes).name);
+            else
+                LOG_WARN("%s: icon theme not found", icon_theme);
+
+            mtx_lock(ctx->icon_lock);
+            if (ctx->icon_size > 0) {
+                icon_reload_application_icons(
+                    *ctx->themes, ctx->icon_size, apps);
+            }
+            mtx_unlock(ctx->icon_lock);
+        }
+    }
+
+    read_cache(apps);
 
-    ssize_t bytes = write(ctx->event_fd, &(uint64_t){1}, sizeof(uint64_t));
+    ssize_t bytes = write(ctx->apps_loaded_fd, &(uint64_t){1}, sizeof(uint64_t));
     if (bytes < 0)
         return -errno;
     else if (bytes != (ssize_t)sizeof(uint64_t))
@@ -352,24 +386,17 @@ populate_apps(void *_ctx)
     return 0;
 }
 
-struct fdm_data {
-    struct wayland *wayl;
-    struct application_list *apps;
-    struct matches *matches;
-    struct prompt *prompt;
-};
-
 /*
  * Called when the application list has been populated
  */
 static bool
 fdm_apps_populated(struct fdm *fdm, int fd, int events, void *_data)
 {
-    struct fdm_data *data = _data;
-    struct wayland *wayl = data->wayl;
-    struct application_list *apps = data->apps;
-    struct matches *matches = data->matches;
-    struct prompt *prompt = data->prompt;
+    struct context *ctx = _data;
+    struct wayland *wayl = ctx->wayl;
+    struct application_list *apps = ctx->apps;
+    struct matches *matches = ctx->matches;
+    struct prompt *prompt = ctx->prompt;
 
     /* Update matches list, then refresh the GUI */
     matches_set_applications(matches, apps);
@@ -774,7 +801,6 @@ main(int argc, char *const *argv)
     log_init(LOG_COLORIZE_AUTO, true, LOG_FACILITY_USER, LOG_CLASS_INFO);
     fcft_log_init(FCFT_LOG_COLORIZE_AUTO, true, FCFT_LOG_CLASS_INFO);
 
-    /* Load applications */
     struct application_list *apps = NULL;
     struct fdm *fdm = NULL;
     struct prompt *prompt = NULL;
@@ -783,8 +809,14 @@ main(int argc, char *const *argv)
     struct wayland *wayl = NULL;
 
     thrd_t app_thread_id;
-    bool join_thread = false;
-    int event_fd = -1;
+    bool join_app_thread = false;
+    int apps_loaded_fd = -1;
+    mtx_t icon_lock;
+
+    if (mtx_init(&icon_lock, mtx_plain) != thrd_success) {
+        LOG_ERR("failed to create lock");
+        return EXIT_FAILURE;
+    }
 
     char *lock_file = NULL;
     int file_lock_fd = -1;
@@ -798,14 +830,6 @@ main(int argc, char *const *argv)
             goto out;
     }
 
-    if (icons_enabled) {
-        themes = icon_load_theme(icon_theme);
-        if (tll_length(themes) > 0)
-            LOG_INFO("theme: %s", tll_front(themes).name);
-        else
-            LOG_WARN("%s: icon theme not found", icon_theme);
-    }
-
     if ((fdm = fdm_init()) == NULL)
         goto out;
 
@@ -837,53 +861,50 @@ main(int argc, char *const *argv)
         matches_update(matches, prompt);
     }
 
-    struct font_reload_context font_reloaded_data = {
-        .icons_enabled = icons_enabled,
-        .themes = &themes,
+    struct context ctx = {
+        .render = render,
+        .matches = matches,
+        .prompt = prompt,
         .apps = apps,
+        .themes = &themes,
+        .icon_lock = &icon_lock,
+        .options = {
+            .icon_theme = icon_theme,
+            .terminal = terminal,
+            .icons_enabled = icons_enabled,
+            .actions_enabled = actions_enabled,
+            .dmenu_mode = dmenu_mode,
+        },
+        .apps_loaded_fd = -1,
     };
 
     if ((wayl = wayl_init(
              fdm, render, prompt, matches, &render_options,
              dmenu_mode, launch_prefix, output_name, font_name, dpi_aware,
-             &font_reloaded, &font_reloaded_data)) == NULL)
+             &font_reloaded, &ctx)) == NULL)
         goto out;
-    wayl_refresh(wayl);
-
-    struct populate_apps_context populate_apps_context = {
-        .apps = apps,
-        .terminal = terminal,
-        .actions_enabled = actions_enabled,
-        .dmenu_mode = dmenu_mode,
-        .event_fd = -1,
-    };
 
-    struct fdm_data fdm_data = {
-        .wayl = wayl,
-        .apps = apps,
-        .matches = matches,
-        .prompt = prompt,
-    };
+    ctx.wayl = wayl;
+    wayl_refresh(wayl);
 
     /* Create thread that will populate the application list */
     if (!dmenu_mode || !no_run_if_empty) {
-        event_fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-        if (event_fd < 0) {
+        ctx.apps_loaded_fd = apps_loaded_fd =
+            eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+
+        if (apps_loaded_fd < 0) {
             LOG_ERRNO("failed to create event FD");
             goto out;
         }
 
-        populate_apps_context.event_fd = event_fd;
-
-        if (thrd_create(&app_thread_id, &populate_apps,
-                        &populate_apps_context) != thrd_success)
-        {
+        if (thrd_create(&app_thread_id, &populate_apps, &ctx) != thrd_success) {
             LOG_ERR("failed to create thread");
             goto out;
         }
-        join_thread = true;
 
-        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &fdm_data))
+        join_app_thread = true;
+
+        if (!fdm_add(fdm, apps_loaded_fd, EPOLLIN, &fdm_apps_populated, &ctx))
             goto out;
     }
 
@@ -899,7 +920,7 @@ main(int argc, char *const *argv)
     ret = wayl_exit_code(wayl);
 
 out:
-    if (join_thread) {
+    if (join_app_thread) {
         int res;
         thrd_join(app_thread_id, &res);
 
@@ -912,8 +933,10 @@ out:
         }
     }
 
-    if (event_fd >= 0)
-        close(event_fd);
+    if (apps_loaded_fd >= 0)
+        close(apps_loaded_fd);
+
+    mtx_destroy(&icon_lock);
 
     shm_fini();
 
diff --git a/wayland.h b/wayland.h
index 4a028fd..ba5fe7d 100644
--- a/wayland.h
+++ b/wayland.h
@@ -34,4 +34,5 @@ void wayl_flush(struct wayland *wayl);
 bool wayl_exit_code(const struct wayland *wayl);
 bool wayl_update_cache(const struct wayland *wayl);
 
+
 bool wayl_size_font_by_dpi(const struct wayland *wayl);
-- 
2.30.2


From eb048aab23b3efb442151a18ae971f96cd14120c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 22:54:10 +0100
Subject: [PATCH 08/23] application: simplify allocation + init of list

---
 application.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/application.c b/application.c
index 9c8b861..c746adf 100644
--- a/application.c
+++ b/application.c
@@ -217,9 +217,7 @@ application_execute(const struct application *app, const struct prompt *prompt,
 struct application_list *
 applications_init(void)
 {
-    struct application_list *apps = malloc(sizeof(*apps));
-    *apps = (struct application_list){};
-    return apps;
+    return calloc(1, sizeof(struct application_list));
 }
 
 void
-- 
2.30.2


From b50a12a0fb31bce9a2289323ca4b9f6cfe6ec1a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 22:55:34 +0100
Subject: [PATCH 09/23] main+render: protect icon loading+rendering with a lock
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Now that icon loading is threaded, we may end up rendering at the same
time the icons are refreshing.

This is bad, since the renderer may access image data that has been
free:d.

To handle this, we introduce an “icon lock”. This icon lock is managed
by main(), and passed by pointer to the renderer.

This lock is taken before refreshing the icons (which happens either
when the font is being reloaded, or during startup, after we’ve
populated the application list).

When rendering, we *try* to take the lock. If we succeed, we render
all icons. If not, no icons are rendered.

The reason for this is: we don’t want to render icons of mixed
size. I.e. we don’t want a per-icon lock.

But we also don’t want to delay rendering (i.e. block on a mtx_lock()
call), since loading the icons can take some time, and during this
time, the GUI will appear to have frozen.

Note that we always refresh the GUI after having refreshed the
icons. Thus, if we do end up rendering a frame without icons, we’ll
re-render again, as soon as the icons have finished loading.
---
 main.c   | 91 ++++++++++++++++++++++++++++++++++++--------------------
 render.c | 18 +++++++++--
 render.h |  4 ++-
 3 files changed, 76 insertions(+), 37 deletions(-)

diff --git a/main.c b/main.c
index aec886f..29516bd 100644
--- a/main.c
+++ b/main.c
@@ -52,7 +52,7 @@ struct context {
         bool dmenu_mode;
     } options;
 
-    int apps_loaded_fd;
+    int event_fd;
 };
 
 static struct rgba
@@ -258,7 +258,6 @@ font_reloaded(struct wayland *wayl, struct fcft_font *font, void *data)
     mtx_lock(ctx->icon_lock);
     {
         ctx->icon_size = font->height;
-
         if (ctx->options.icons_enabled) {
             icon_reload_application_icons(
                 *ctx->themes, ctx->icon_size, ctx->apps);
@@ -342,6 +341,8 @@ acquire_file_lock(const char *path, int *fd)
     return true;
 }
 
+enum { EVENT_APPS_LOADED = 1, EVENT_ICONS_LOADED = 2 };
+
 /* THREAD */
 static int
 populate_apps(void *_ctx)
@@ -359,6 +360,15 @@ populate_apps(void *_ctx)
 
     else {
         xdg_find_programs(terminal, actions_enabled, apps);
+        read_cache(apps);
+
+        ssize_t bytes = write(
+            ctx->event_fd, &(uint64_t){EVENT_APPS_LOADED}, sizeof(uint64_t));
+
+        if (bytes < 0)
+            return -errno;
+        else if (bytes != (ssize_t)sizeof(uint64_t))
+            return 1;
 
         if (icons_enabled) {
             *ctx->themes = icon_load_theme(icon_theme);
@@ -373,16 +383,17 @@ populate_apps(void *_ctx)
                     *ctx->themes, ctx->icon_size, apps);
             }
             mtx_unlock(ctx->icon_lock);
+
+            ssize_t bytes = write(
+                ctx->event_fd, &(uint64_t){EVENT_ICONS_LOADED}, sizeof(uint64_t));
+
+            if (bytes < 0)
+                return -errno;
+            else if (bytes != (ssize_t)sizeof(uint64_t))
+                return 1;
         }
     }
 
-    read_cache(apps);
-
-    ssize_t bytes = write(ctx->apps_loaded_fd, &(uint64_t){1}, sizeof(uint64_t));
-    if (bytes < 0)
-        return -errno;
-    else if (bytes != (ssize_t)sizeof(uint64_t))
-        return 1;
     return 0;
 }
 
@@ -390,20 +401,34 @@ populate_apps(void *_ctx)
  * Called when the application list has been populated
  */
 static bool
-fdm_apps_populated(struct fdm *fdm, int fd, int events, void *_data)
+fdm_apps_populated(struct fdm *fdm, int fd, int events, void *data)
 {
-    struct context *ctx = _data;
+    uint64_t event;
+    ssize_t bytes = read(fd, &event, sizeof(event));
+    if (bytes < 0) {
+        LOG_ERRNO("failed to read event FD");
+        return false;
+    }
+
+    struct context *ctx = data;
     struct wayland *wayl = ctx->wayl;
     struct application_list *apps = ctx->apps;
     struct matches *matches = ctx->matches;
     struct prompt *prompt = ctx->prompt;
 
-    /* Update matches list, then refresh the GUI */
-    matches_set_applications(matches, apps);
-    matches_update(matches, prompt);
-    wayl_refresh(wayl);
+    switch (event) {
+    case EVENT_APPS_LOADED:
+        /* Update matches list, then refresh the GUI */
+        matches_set_applications(matches, apps);
+        matches_update(matches, prompt);
+        break;
+
+    case EVENT_ICONS_LOADED:
+        /* Just need to refresh the GUI */
+        break;
+    }
 
-    fdm_del_no_close(fdm, fd);
+    wayl_refresh(wayl);
     return true;
 }
 
@@ -801,6 +826,12 @@ main(int argc, char *const *argv)
     log_init(LOG_COLORIZE_AUTO, true, LOG_FACILITY_USER, LOG_CLASS_INFO);
     fcft_log_init(FCFT_LOG_COLORIZE_AUTO, true, FCFT_LOG_CLASS_INFO);
 
+    mtx_t icon_lock;
+    if (mtx_init(&icon_lock, mtx_plain) != thrd_success) {
+        LOG_ERR("failed to create icon lock");
+        return EXIT_FAILURE;
+    }
+
     struct application_list *apps = NULL;
     struct fdm *fdm = NULL;
     struct prompt *prompt = NULL;
@@ -810,13 +841,7 @@ main(int argc, char *const *argv)
 
     thrd_t app_thread_id;
     bool join_app_thread = false;
-    int apps_loaded_fd = -1;
-    mtx_t icon_lock;
-
-    if (mtx_init(&icon_lock, mtx_plain) != thrd_success) {
-        LOG_ERR("failed to create lock");
-        return EXIT_FAILURE;
-    }
+    int event_fd = -1;
 
     char *lock_file = NULL;
     int file_lock_fd = -1;
@@ -833,7 +858,7 @@ main(int argc, char *const *argv)
     if ((fdm = fdm_init()) == NULL)
         goto out;
 
-    if ((render = render_init(&render_options)) == NULL)
+    if ((render = render_init(&render_options, &icon_lock)) == NULL)
         goto out;
 
     if ((prompt = prompt_init(prompt_content)) == NULL)
@@ -875,7 +900,7 @@ main(int argc, char *const *argv)
             .actions_enabled = actions_enabled,
             .dmenu_mode = dmenu_mode,
         },
-        .apps_loaded_fd = -1,
+        .event_fd = -1,
     };
 
     if ((wayl = wayl_init(
@@ -889,11 +914,9 @@ main(int argc, char *const *argv)
 
     /* Create thread that will populate the application list */
     if (!dmenu_mode || !no_run_if_empty) {
-        ctx.apps_loaded_fd = apps_loaded_fd =
-            eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-
-        if (apps_loaded_fd < 0) {
-            LOG_ERRNO("failed to create event FD");
+        ctx.event_fd = event_fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+        if (event_fd < 0) {
+            LOG_ERRNO("failed to create event FDs");
             goto out;
         }
 
@@ -904,7 +927,7 @@ main(int argc, char *const *argv)
 
         join_app_thread = true;
 
-        if (!fdm_add(fdm, apps_loaded_fd, EPOLLIN, &fdm_apps_populated, &ctx))
+        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &ctx))
             goto out;
     }
 
@@ -933,8 +956,10 @@ out:
         }
     }
 
-    if (apps_loaded_fd >= 0)
-        close(apps_loaded_fd);
+    if (event_fd >= 0) {
+        fdm_del_no_close(fdm, event_fd);
+        close(event_fd);
+    }
 
     mtx_destroy(&icon_lock);
 
diff --git a/render.c b/render.c
index f99319f..86c6101 100644
--- a/render.c
+++ b/render.c
@@ -34,6 +34,8 @@ struct render {
     unsigned border_size;
     unsigned row_height;
     unsigned icon_height;
+
+    mtx_t *icon_lock;
 };
 
 static pixman_color_t
@@ -526,6 +528,8 @@ render_match_list(const struct render *render, struct buffer *buf,
 
     int y = first_row + (row_height + font->height) / 2 - font->descent;
 
+    bool render_icons = mtx_trylock(render->icon_lock) == thrd_success;
+
     for (size_t i = 0; i < match_count; i++) {
         if (y + font->descent > buf->height - y_margin - border_size) {
             /* Window too small - happens if the compositor doesn't
@@ -546,8 +550,12 @@ render_match_list(const struct render *render, struct buffer *buf,
 
             const double list_end = first_row + match_count * row_height;
 
-            if (match->application->icon.type == ICON_SVG && img_y > list_end)
+            if (render_icons &&
+                match->application->icon.type == ICON_SVG &&
+                img_y > list_end)
+            {
                 render_svg(&match->application->icon, img_x, img_y, size, buf);
+            }
 
             pixman_color_t sc = rgba2pixman(render->options.selection_color);
             pixman_image_fill_rectangles(
@@ -573,7 +581,7 @@ render_match_list(const struct render *render, struct buffer *buf,
             );
 #endif
 
-        {
+        if (render_icons) {
             struct icon *icon = &match->application->icon;
             const int size = render->icon_height;
             const int img_x = cur_x;
@@ -609,14 +617,18 @@ render_match_list(const struct render *render, struct buffer *buf,
 
         y += row_height;
     }
+
+    if (render_icons)
+        mtx_unlock(render->icon_lock);
 }
 
 struct render *
-render_init(const struct render_options *options)
+render_init(const struct render_options *options, mtx_t *icon_lock)
 {
     struct render *render = calloc(1, sizeof(*render));
     *render = (struct render){
         .options = *options,
+        .icon_lock = icon_lock,
     };
 
     /* TODO: the one providing the opti3Dons should calculate these */
diff --git a/render.h b/render.h
index 1a312e0..070868f 100644
--- a/render.h
+++ b/render.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <threads.h>
 #include <pixman.h>
 
 #include <fcft/fcft.h>
@@ -42,7 +43,8 @@ struct render_options {
 };
 
 struct render;
-struct render *render_init(const struct render_options *options);
+struct render *render_init(
+    const struct render_options *options, mtx_t *icon_lock);
 void render_destroy(struct render *render);
 
 void render_set_subpixel(struct render *render, enum fcft_subpixel subpixel);
-- 
2.30.2


From 79a2047124457fff5e9b6997b4f4394bebfb78e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 23:00:06 +0100
Subject: [PATCH 10/23] render: repair comment

---
 render.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/render.c b/render.c
index 86c6101..1496ad5 100644
--- a/render.c
+++ b/render.c
@@ -631,7 +631,7 @@ render_init(const struct render_options *options, mtx_t *icon_lock)
         .icon_lock = icon_lock,
     };
 
-    /* TODO: the one providing the opti3Dons should calculate these */
+    /* TODO: the one providing the options should calculate these */
     render->options.pix_background_color = rgba2pixman(render->options.background_color);
     render->options.pix_border_color = rgba2pixman(render->options.border_color);
     render->options.pix_text_color = rgba2pixman(render->options.text_color);
-- 
2.30.2


From c9247b767691bbfc5d2075c3b0a1bbf1d9f30aee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 23:05:00 +0100
Subject: [PATCH 11/23] changelog: icon loading is offloaded to a thread

---
 CHANGELOG.md | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index bd40091..2ee7a7a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -51,6 +51,9 @@
 * The application list is now populated in a separate thread, in
   parallel to initializing the GUI. This reduces the risk of missing
   keyboard input (https://codeberg.org/dnkl/fuzzel/issues/82).
+* Icons are now loaded in a thread. This allows us to display the
+  application list quickly (initially without icons, if loading them
+  takes “too” long).
 
 
 ### Deprecated
-- 
2.30.2


From 8d8e2fa8e47ee41963c4d13e0b412c518cb5785c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sat, 8 Jan 2022 23:09:56 +0100
Subject: [PATCH 12/23] main: repair --dmenu
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We didn’t send an EVENT_APPS_LOADED event after loading dmenu entries,
causing the window to empty.
---
 main.c | 68 ++++++++++++++++++++++++++++++++--------------------------
 1 file changed, 37 insertions(+), 31 deletions(-)

diff --git a/main.c b/main.c
index 29516bd..e11a6e4 100644
--- a/main.c
+++ b/main.c
@@ -341,7 +341,20 @@ acquire_file_lock(const char *path, int *fd)
     return true;
 }
 
-enum { EVENT_APPS_LOADED = 1, EVENT_ICONS_LOADED = 2 };
+enum event_type { EVENT_APPS_LOADED = 1, EVENT_ICONS_LOADED = 2 };
+
+static int
+send_event(int fd, enum event_type event)
+{
+    ssize_t bytes = write(fd, &(uint64_t){event}, sizeof(uint64_t));
+
+    if (bytes < 0)
+        return -errno;
+    else if (bytes != (ssize_t)sizeof(uint64_t))
+        return 1;
+    return 0;
+}
+
 
 /* THREAD */
 static int
@@ -355,43 +368,36 @@ populate_apps(void *_ctx)
     bool dmenu_mode = ctx->options.dmenu_mode;
     bool icons_enabled = ctx->options.icons_enabled;
 
-    if (dmenu_mode)
+    if (dmenu_mode) {
         dmenu_load_entries(apps);
+        return send_event(ctx->event_fd, EVENT_APPS_LOADED);
+    }
 
-    else {
-        xdg_find_programs(terminal, actions_enabled, apps);
-        read_cache(apps);
-
-        ssize_t bytes = write(
-            ctx->event_fd, &(uint64_t){EVENT_APPS_LOADED}, sizeof(uint64_t));
 
-        if (bytes < 0)
-            return -errno;
-        else if (bytes != (ssize_t)sizeof(uint64_t))
-            return 1;
+    xdg_find_programs(terminal, actions_enabled, apps);
+    read_cache(apps);
 
-        if (icons_enabled) {
-            *ctx->themes = icon_load_theme(icon_theme);
-            if (tll_length(*ctx->themes) > 0)
-                LOG_INFO("theme: %s", tll_front(*ctx->themes).name);
-            else
-                LOG_WARN("%s: icon theme not found", icon_theme);
+    int r = send_event(ctx->event_fd, EVENT_APPS_LOADED);
+    if (r != 0)
+        return r;
 
-            mtx_lock(ctx->icon_lock);
-            if (ctx->icon_size > 0) {
-                icon_reload_application_icons(
-                    *ctx->themes, ctx->icon_size, apps);
-            }
-            mtx_unlock(ctx->icon_lock);
+    if (icons_enabled) {
+        *ctx->themes = icon_load_theme(icon_theme);
+        if (tll_length(*ctx->themes) > 0)
+            LOG_INFO("theme: %s", tll_front(*ctx->themes).name);
+        else
+            LOG_WARN("%s: icon theme not found", icon_theme);
 
-            ssize_t bytes = write(
-                ctx->event_fd, &(uint64_t){EVENT_ICONS_LOADED}, sizeof(uint64_t));
-
-            if (bytes < 0)
-                return -errno;
-            else if (bytes != (ssize_t)sizeof(uint64_t))
-                return 1;
+        mtx_lock(ctx->icon_lock);
+        if (ctx->icon_size > 0) {
+            icon_reload_application_icons(
+                *ctx->themes, ctx->icon_size, apps);
         }
+        mtx_unlock(ctx->icon_lock);
+
+        r = send_event(ctx->event_fd, EVENT_ICONS_LOADED);
+        if (r != 0)
+            return r;
     }
 
     return 0;
-- 
2.30.2


From 5f6a00f042159c44c627a35a24e6b7037acdd201 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 11:14:20 +0100
Subject: [PATCH 13/23] main: start thread before rendering the first frame

Starting the threads is cheap. Rendering a frame is more expensive.
---
 main.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/main.c b/main.c
index e11a6e4..7ba6c70 100644
--- a/main.c
+++ b/main.c
@@ -916,7 +916,6 @@ main(int argc, char *const *argv)
         goto out;
 
     ctx.wayl = wayl;
-    wayl_refresh(wayl);
 
     /* Create thread that will populate the application list */
     if (!dmenu_mode || !no_run_if_empty) {
@@ -937,6 +936,8 @@ main(int argc, char *const *argv)
             goto out;
     }
 
+    wayl_refresh(wayl);
+
     while (true) {
         wayl_flush(wayl);
         if (!fdm_poll(fdm))
-- 
2.30.2


From cb04429111759e47ee6bd1d169efebf5cbaa416b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 12:28:38 +0100
Subject: [PATCH 14/23] main: add event-fd to FDM before creating thread

---
 main.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/main.c b/main.c
index 7ba6c70..5ace0c0 100644
--- a/main.c
+++ b/main.c
@@ -373,7 +373,6 @@ populate_apps(void *_ctx)
         return send_event(ctx->event_fd, EVENT_APPS_LOADED);
     }
 
-
     xdg_find_programs(terminal, actions_enabled, apps);
     read_cache(apps);
 
@@ -925,15 +924,15 @@ main(int argc, char *const *argv)
             goto out;
         }
 
+        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &ctx))
+            goto out;
+
         if (thrd_create(&app_thread_id, &populate_apps, &ctx) != thrd_success) {
             LOG_ERR("failed to create thread");
             goto out;
         }
 
         join_app_thread = true;
-
-        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &ctx))
-            goto out;
     }
 
     wayl_refresh(wayl);
-- 
2.30.2


From 5b88cf6c7c63fd73b446cc095fd21f12b9d58308 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 12:41:52 +0100
Subject: [PATCH 15/23] main: use a pipe instead of an event FD for thread
 signaling
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The thread that populates the application list, and loads the initial
set of icons, previously used an event FD to signal when its done.

This was done by writing an event enum to the event FD; once when the
application list has been loaded, and once when the icons have been
loaded.

The problem is that an event FD will *add* the written value to its
current counter value.

In other words, if the thread finished very quickly, it’d end up
writing a ‘1’ and a ‘2’, *before* the main thread had had a chance to
read anything from the event FD.

Then, when the main thread *did* read the event FD, it’d get
‘3’ (1+2). This didn’t match any of the events, and nothing was
refreshed, resulting in an empty window.

This patch replaces the event FD with a regular pipe.
---
 main.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/main.c b/main.c
index 5ace0c0..66ea93a 100644
--- a/main.c
+++ b/main.c
@@ -12,7 +12,6 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/file.h>
-#include <sys/eventfd.h>
 #include <sys/epoll.h>
 #include <fcntl.h>
 #include <dirent.h>
@@ -846,7 +845,7 @@ main(int argc, char *const *argv)
 
     thrd_t app_thread_id;
     bool join_app_thread = false;
-    int event_fd = -1;
+    int event_pipe[2] = {-1, -1};
 
     char *lock_file = NULL;
     int file_lock_fd = -1;
@@ -918,13 +917,14 @@ main(int argc, char *const *argv)
 
     /* Create thread that will populate the application list */
     if (!dmenu_mode || !no_run_if_empty) {
-        ctx.event_fd = event_fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-        if (event_fd < 0) {
-            LOG_ERRNO("failed to create event FDs");
+        if (pipe2(event_pipe, O_CLOEXEC | O_NONBLOCK) < 0) {
+            LOG_ERRNO("failed to create event pipe");
             goto out;
         }
 
-        if (!fdm_add(fdm, event_fd, EPOLLIN, &fdm_apps_populated, &ctx))
+        ctx.event_fd = event_pipe[1];
+
+        if (!fdm_add(fdm, event_pipe[0], EPOLLIN, &fdm_apps_populated, &ctx))
             goto out;
 
         if (thrd_create(&app_thread_id, &populate_apps, &ctx) != thrd_success) {
@@ -962,10 +962,12 @@ out:
         }
     }
 
-    if (event_fd >= 0) {
-        fdm_del_no_close(fdm, event_fd);
-        close(event_fd);
+    if (event_pipe[0] >= 0) {
+        fdm_del_no_close(fdm, event_pipe[0]);
+        close(event_pipe[0]);
     }
+    if (event_pipe[1] >= 0)
+        close(event_pipe[1]);
 
     mtx_destroy(&icon_lock);
 
-- 
2.30.2


From fa1560e0b1a4d3f451a1ea852cc8594bc39cbcc9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 12:53:17 +0100
Subject: [PATCH 16/23] main: protect assignment to ctx->themes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This member is not a pointer, and the assignment isn’t atomic.
---
 main.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/main.c b/main.c
index 66ea93a..d35ec03 100644
--- a/main.c
+++ b/main.c
@@ -380,16 +380,19 @@ populate_apps(void *_ctx)
         return r;
 
     if (icons_enabled) {
-        *ctx->themes = icon_load_theme(icon_theme);
-        if (tll_length(*ctx->themes) > 0)
-            LOG_INFO("theme: %s", tll_front(*ctx->themes).name);
+        icon_theme_list_t icon_themes = icon_load_theme(icon_theme);
+        if (tll_length(icon_themes) > 0)
+            LOG_INFO("theme: %s", tll_front(icon_themes).name);
         else
             LOG_WARN("%s: icon theme not found", icon_theme);
 
         mtx_lock(ctx->icon_lock);
-        if (ctx->icon_size > 0) {
-            icon_reload_application_icons(
-                *ctx->themes, ctx->icon_size, apps);
+        {
+            *ctx->themes = icon_themes;
+            if (ctx->icon_size > 0) {
+                icon_reload_application_icons(
+                    *ctx->themes, ctx->icon_size, apps);
+            }
         }
         mtx_unlock(ctx->icon_lock);
 
-- 
2.30.2


From ea730354ae9eb5e584b216ef2d1b660dc73e3e0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 20:59:25 +0100
Subject: [PATCH 17/23] main: error out on partial read from event pipe

---
 main.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/main.c b/main.c
index d35ec03..99eef7c 100644
--- a/main.c
+++ b/main.c
@@ -412,8 +412,11 @@ fdm_apps_populated(struct fdm *fdm, int fd, int events, void *data)
 {
     uint64_t event;
     ssize_t bytes = read(fd, &event, sizeof(event));
-    if (bytes < 0) {
-        LOG_ERRNO("failed to read event FD");
+    if (bytes != (ssize_t)sizeof(event)) {
+        if (bytes < 0)
+            LOG_ERRNO("failed to read event FD");
+        else
+            LOG_ERR("partial read from event FD");
         return false;
     }
 
-- 
2.30.2


From 48b498e1d5442657a9ffb91c9a773986fed8e7cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 20:59:46 +0100
Subject: [PATCH 18/23] main: error out on HUP in event pipe

---
 main.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/main.c b/main.c
index 99eef7c..0cfc4b5 100644
--- a/main.c
+++ b/main.c
@@ -410,6 +410,9 @@ populate_apps(void *_ctx)
 static bool
 fdm_apps_populated(struct fdm *fdm, int fd, int events, void *data)
 {
+    if (events & EPOLLHUP)
+        return false;
+
     uint64_t event;
     ssize_t bytes = read(fd, &event, sizeof(event));
     if (bytes != (ssize_t)sizeof(event)) {
-- 
2.30.2


From 286631d696306ee58137ac7d39dc2d616a42e142 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 21:00:46 +0100
Subject: [PATCH 19/23] main: error out on unrecognized event type

---
 main.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/main.c b/main.c
index 0cfc4b5..f69fe51 100644
--- a/main.c
+++ b/main.c
@@ -439,6 +439,10 @@ fdm_apps_populated(struct fdm *fdm, int fd, int events, void *data)
     case EVENT_ICONS_LOADED:
         /* Just need to refresh the GUI */
         break;
+
+    default:
+        LOG_ERR("unknown event: %llx", (long long)event);
+        return false;
     }
 
     wayl_refresh(wayl);
-- 
2.30.2


From f78f5720c47c01a4d24e19e0bd6fddc7136e0934 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Sun, 9 Jan 2022 22:44:42 +0100
Subject: [PATCH 20/23] wayland: error handling

Check return values from wl_display_read_events() and
wl_display_dispatch_pending().

Exit on failure.
---
 wayland.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/wayland.c b/wayland.c
index 443eb39..ca5ad3f 100644
--- a/wayland.c
+++ b/wayland.c
@@ -1508,15 +1508,22 @@ fdm_handler(struct fdm *fdm, int fd, int events, void *data)
     struct wayland *wayl = data;
     int event_count = 0;
 
-    if (events & EPOLLIN)
-        wl_display_read_events(wayl->display);
+    if (events & EPOLLIN) {
+        if (wl_display_read_events(wayl->display) < 0) {
+            LOG_ERRNO("failed to read events from the Wayland socket");
+            return false;
+        }
 
-    while (wl_display_prepare_read(wayl->display) != 0)
-        wl_display_dispatch_pending(wayl->display);
+        while (wl_display_prepare_read(wayl->display) != 0)
+            if (wl_display_dispatch_pending(wayl->display) < 0) {
+                LOG_ERRNO("failed to dispatch pending Wayland events");
+                return false;
+            }
+    }
 
     if (events & EPOLLHUP) {
         LOG_WARN("disconnected from Wayland");
-        wl_display_cancel_read(wayl->display);
+        // wl_display_cancel_read(wayl->display);
         return false;
     }
 
-- 
2.30.2


From 8e38dbe8d16a0e66bf0300abecd589c8436608a4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Tue, 11 Jan 2022 20:24:08 +0100
Subject: [PATCH 21/23] wayland: remove spurious newline

---
 wayland.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/wayland.h b/wayland.h
index ba5fe7d..4a028fd 100644
--- a/wayland.h
+++ b/wayland.h
@@ -34,5 +34,4 @@ void wayl_flush(struct wayland *wayl);
 bool wayl_exit_code(const struct wayland *wayl);
 bool wayl_update_cache(const struct wayland *wayl);
 
-
 bool wayl_size_font_by_dpi(const struct wayland *wayl);
-- 
2.30.2


From 9b429bd4d4e5f8fcaeecf9c36c39f53c1b3ea889 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Tue, 11 Jan 2022 20:24:16 +0100
Subject: [PATCH 22/23] match: remove commented out code

---
 match.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/match.c b/match.c
index 24776c6..5a85b1e 100644
--- a/match.c
+++ b/match.c
@@ -160,15 +160,14 @@ match_levenshtein(struct matches *matches,
 }
 
 struct matches *
-matches_init(/*const struct application_list *applications,*/
-             enum match_fields fields, bool fuzzy, size_t fuzzy_min_length,
+matches_init(enum match_fields fields, bool fuzzy, size_t fuzzy_min_length,
              size_t fuzzy_max_length_discrepancy, size_t fuzzy_max_distance)
 {
     struct matches *matches = malloc(sizeof(*matches));
     *matches = (struct matches) {
         .applications = NULL,
         .fields = fields,
-        .matches = NULL, //malloc(applications->count * sizeof(matches->matches[0])),
+        .matches = NULL,
         .fuzzy = fuzzy,
         .page_count = 0,
         .match_count = 0,
-- 
2.30.2


From a9d867cb3d0792ad0998ebff447b00a749789a30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Ekl=C3=B6f?= <daniel@ekloef.se>
Date: Tue, 11 Jan 2022 20:25:29 +0100
Subject: [PATCH 23/23] wayland: remove commented out code

---
 wayland.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/wayland.c b/wayland.c
index ca5ad3f..332f1d8 100644
--- a/wayland.c
+++ b/wayland.c
@@ -1523,7 +1523,6 @@ fdm_handler(struct fdm *fdm, int fd, int events, void *data)
 
     if (events & EPOLLHUP) {
         LOG_WARN("disconnected from Wayland");
-        // wl_display_cancel_read(wayl->display);
         return false;
     }
 
-- 
2.30.2

