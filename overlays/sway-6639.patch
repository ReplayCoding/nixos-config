From 630388b2e17d019258afa8e3d4b74a7a482933e6 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Sun, 24 Oct 2021 18:49:39 -0700
Subject: [PATCH 01/12] output: change output::destroy to output::disable

This changes output::destroy to output::disable and emits it only
once when an output is disabled, instead of twice in succession.
---
 include/sway/output.h      | 2 +-
 sway/desktop/layer_shell.c | 2 +-
 sway/desktop/output.c      | 8 ++++++--
 sway/tree/output.c         | 8 ++------
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/include/sway/output.h b/include/sway/output.h
index 5dfe0fff91..26b9709f98 100644
--- a/include/sway/output.h
+++ b/include/sway/output.h
@@ -48,7 +48,7 @@ struct sway_output {
 	struct wl_listener damage_frame;
 
 	struct {
-		struct wl_signal destroy;
+		struct wl_signal disable;
 	} events;
 
 	struct timespec last_presentation;
diff --git a/sway/desktop/layer_shell.c b/sway/desktop/layer_shell.c
index 7f5a337b32..71563d1ec1 100644
--- a/sway/desktop/layer_shell.c
+++ b/sway/desktop/layer_shell.c
@@ -664,7 +664,7 @@ void handle_layer_shell_surface(struct wl_listener *listener, void *data) {
 
 	struct sway_output *output = layer_surface->output->data;
 	sway_layer->output_destroy.notify = handle_output_destroy;
-	wl_signal_add(&output->events.destroy, &sway_layer->output_destroy);
+	wl_signal_add(&output->events.disable, &sway_layer->output_destroy);
 
 	wl_list_insert(&output->layers[layer_surface->pending.layer],
 			&sway_layer->link);
diff --git a/sway/desktop/output.c b/sway/desktop/output.c
index edec71ad1d..1bca43925e 100644
--- a/sway/desktop/output.c
+++ b/sway/desktop/output.c
@@ -755,18 +755,22 @@ static void update_output_manager_config(struct sway_server *server) {
 static void handle_destroy(struct wl_listener *listener, void *data) {
 	struct sway_output *output = wl_container_of(listener, output, destroy);
 	struct sway_server *server = output->server;
-	wl_signal_emit(&output->events.destroy, output);
+	output_begin_destroy(output);
 
 	if (output->enabled) {
 		output_disable(output);
 	}
-	output_begin_destroy(output);
+
+	wl_list_remove(&output->link);
 
 	wl_list_remove(&output->destroy.link);
 	wl_list_remove(&output->commit.link);
 	wl_list_remove(&output->mode.link);
 	wl_list_remove(&output->present.link);
 
+	output->wlr_output->data = NULL;
+	output->wlr_output = NULL;
+
 	transaction_commit_dirty();
 
 	update_output_manager_config(server);
diff --git a/sway/tree/output.c b/sway/tree/output.c
index c095dce06e..9102f3391b 100644
--- a/sway/tree/output.c
+++ b/sway/tree/output.c
@@ -95,7 +95,7 @@ struct sway_output *output_create(struct wlr_output *wlr_output) {
 	output->detected_subpixel = wlr_output->subpixel;
 	output->scale_filter = SCALE_FILTER_NEAREST;
 
-	wl_signal_init(&output->events.destroy);
+	wl_signal_init(&output->events.disable);
 
 	wl_list_insert(&root->all_outputs, &output->link);
 
@@ -262,7 +262,7 @@ void output_disable(struct sway_output *output) {
 	}
 
 	sway_log(SWAY_DEBUG, "Disabling output '%s'", output->wlr_output->name);
-	wl_signal_emit(&output->events.destroy, output);
+	wl_signal_emit(&output->events.disable, output);
 
 	output_evacuate(output);
 
@@ -289,10 +289,6 @@ void output_begin_destroy(struct sway_output *output) {
 
 	output->node.destroying = true;
 	node_set_dirty(&output->node);
-
-	wl_list_remove(&output->link);
-	output->wlr_output->data = NULL;
-	output->wlr_output = NULL;
 }
 
 struct sway_output *output_from_wlr_output(struct wlr_output *output) {

From bd502402737e5ac9136392f1e65715cefe3a041b Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Sun, 24 Oct 2021 18:51:16 -0700
Subject: [PATCH 02/12] output: emit node::destroy event

Now output_begin_destroy emits the node::destroy event similar to
workspace_begin_destroy. It currently has no listeners, since they
listen to output::disable or wlr_output::destroy instead.
---
 sway/tree/output.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/sway/tree/output.c b/sway/tree/output.c
index 9102f3391b..6a0963c80a 100644
--- a/sway/tree/output.c
+++ b/sway/tree/output.c
@@ -286,6 +286,7 @@ void output_begin_destroy(struct sway_output *output) {
 		return;
 	}
 	sway_log(SWAY_DEBUG, "Destroying output '%s'", output->wlr_output->name);
+	wl_signal_emit(&output->node.events.destroy, &output->node);
 
 	output->node.destroying = true;
 	node_set_dirty(&output->node);

From d44f9f804407ed62edd6c5361173e146d32b6f5e Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Sun, 24 Oct 2021 16:18:49 -0700
Subject: [PATCH 03/12] root: move the workspace matching code to its own file

This removes the pid_workspace bits from tree/root before it gets
too interesting.

No functional change.
---
 include/sway/desktop/launcher.h |  14 +++
 include/sway/tree/root.h        |   8 --
 sway/commands/exec_always.c     |   1 +
 sway/commands/rename.c          |   1 +
 sway/desktop/launcher.c         | 189 ++++++++++++++++++++++++++++++++
 sway/meson.build                |   1 +
 sway/tree/root.c                | 180 ------------------------------
 sway/tree/view.c                |   1 +
 8 files changed, 207 insertions(+), 188 deletions(-)
 create mode 100644 include/sway/desktop/launcher.h
 create mode 100644 sway/desktop/launcher.c

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
new file mode 100644
index 0000000000..cb22eb9809
--- /dev/null
+++ b/include/sway/desktop/launcher.h
@@ -0,0 +1,14 @@
+#ifndef _SWAY_LAUNCHER_H
+#define _SWAY_LAUNCHER_H
+
+#include <stdlib.h>
+
+struct sway_workspace *root_workspace_for_pid(pid_t pid);
+
+void root_record_workspace_pid(pid_t pid);
+
+void root_remove_workspace_pid(pid_t pid);
+
+void root_rename_pid_workspaces(const char *old_name, const char *new_name);
+
+#endif
diff --git a/include/sway/tree/root.h b/include/sway/tree/root.h
index e8f4d57385..492e39ca89 100644
--- a/include/sway/tree/root.h
+++ b/include/sway/tree/root.h
@@ -68,12 +68,6 @@ void root_scratchpad_show(struct sway_container *con);
  */
 void root_scratchpad_hide(struct sway_container *con);
 
-struct sway_workspace *root_workspace_for_pid(pid_t pid);
-
-void root_record_workspace_pid(pid_t pid);
-
-void root_remove_workspace_pid(pid_t pid);
-
 void root_for_each_workspace(void (*f)(struct sway_workspace *ws, void *data),
 		void *data);
 
@@ -91,6 +85,4 @@ struct sway_container *root_find_container(
 
 void root_get_box(struct sway_root *root, struct wlr_box *box);
 
-void root_rename_pid_workspaces(const char *old_name, const char *new_name);
-
 #endif
diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index b35065c12c..fab9a4028f 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -8,6 +8,7 @@
 #include "sway/commands.h"
 #include "sway/config.h"
 #include "sway/server.h"
+#include "sway/desktop/launcher.h"
 #include "sway/tree/container.h"
 #include "sway/tree/root.h"
 #include "sway/tree/workspace.h"
diff --git a/sway/commands/rename.c b/sway/commands/rename.c
index 3b855fdf7e..4656a41099 100644
--- a/sway/commands/rename.c
+++ b/sway/commands/rename.c
@@ -7,6 +7,7 @@
 #include "sway/config.h"
 #include "sway/ipc-server.h"
 #include "sway/output.h"
+#include "sway/desktop/launcher.h"
 #include "sway/tree/container.h"
 #include "sway/tree/workspace.h"
 #include "sway/tree/root.h"
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
new file mode 100644
index 0000000000..33eb4be1d7
--- /dev/null
+++ b/sway/desktop/launcher.c
@@ -0,0 +1,189 @@
+#define _POSIX_C_SOURCE 200809L
+#include <stdlib.h>
+#include <string.h>
+#include "sway/input/seat.h"
+#include "sway/output.h"
+#include "sway/desktop/launcher.h"
+#include "sway/tree/container.h"
+#include "sway/tree/workspace.h"
+#include "log.h"
+
+static struct wl_list pid_workspaces;
+
+struct pid_workspace {
+	pid_t pid;
+	char *workspace;
+	struct timespec time_added;
+
+	struct sway_output *output;
+	struct wl_listener output_destroy;
+
+	struct wl_list link;
+};
+
+/**
+ * Get the pid of a parent process given the pid of a child process.
+ *
+ * Returns the parent pid or NULL if the parent pid cannot be determined.
+ */
+static pid_t get_parent_pid(pid_t child) {
+	pid_t parent = -1;
+	char file_name[100];
+	char *buffer = NULL;
+	const char *sep = " ";
+	FILE *stat = NULL;
+	size_t buf_size = 0;
+
+	sprintf(file_name, "/proc/%d/stat", child);
+
+	if ((stat = fopen(file_name, "r"))) {
+		if (getline(&buffer, &buf_size, stat) != -1) {
+			strtok(buffer, sep); // pid
+			strtok(NULL, sep);   // executable name
+			strtok(NULL, sep);   // state
+			char *token = strtok(NULL, sep);   // parent pid
+			parent = strtol(token, NULL, 10);
+		}
+		free(buffer);
+		fclose(stat);
+	}
+
+	if (parent) {
+		return (parent == child) ? -1 : parent;
+	}
+
+	return -1;
+}
+
+static void pid_workspace_destroy(struct pid_workspace *pw) {
+	wl_list_remove(&pw->output_destroy.link);
+	wl_list_remove(&pw->link);
+	free(pw->workspace);
+	free(pw);
+}
+
+struct sway_workspace *root_workspace_for_pid(pid_t pid) {
+	if (!pid_workspaces.prev && !pid_workspaces.next) {
+		wl_list_init(&pid_workspaces);
+		return NULL;
+	}
+
+	struct sway_workspace *ws = NULL;
+	struct pid_workspace *pw = NULL;
+
+	sway_log(SWAY_DEBUG, "Looking up workspace for pid %d", pid);
+
+	do {
+		struct pid_workspace *_pw = NULL;
+		wl_list_for_each(_pw, &pid_workspaces, link) {
+			if (pid == _pw->pid) {
+				pw = _pw;
+				sway_log(SWAY_DEBUG,
+						"found pid_workspace for pid %d, workspace %s",
+						pid, pw->workspace);
+				goto found;
+			}
+		}
+		pid = get_parent_pid(pid);
+	} while (pid > 1);
+
+found:
+	if (pw && pw->workspace) {
+		ws = workspace_by_name(pw->workspace);
+
+		if (!ws) {
+			sway_log(SWAY_DEBUG,
+					"Creating workspace %s for pid %d because it disappeared",
+					pw->workspace, pid);
+
+			struct sway_output *output = pw->output;
+			if (pw->output && !pw->output->enabled) {
+				sway_log(SWAY_DEBUG,
+						"Workspace output %s is disabled, trying another one",
+						pw->output->wlr_output->name);
+				output = NULL;
+			}
+
+			ws = workspace_create(output, pw->workspace);
+		}
+
+		pid_workspace_destroy(pw);
+	}
+
+	return ws;
+}
+
+static void pw_handle_output_destroy(struct wl_listener *listener, void *data) {
+	struct pid_workspace *pw = wl_container_of(listener, pw, output_destroy);
+	pw->output = NULL;
+	wl_list_remove(&pw->output_destroy.link);
+	wl_list_init(&pw->output_destroy.link);
+}
+
+void root_record_workspace_pid(pid_t pid) {
+	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
+	if (!pid_workspaces.prev && !pid_workspaces.next) {
+		wl_list_init(&pid_workspaces);
+	}
+
+	struct sway_seat *seat = input_manager_current_seat();
+	struct sway_workspace *ws = seat_get_focused_workspace(seat);
+	if (!ws) {
+		sway_log(SWAY_DEBUG, "Bailing out, no workspace");
+		return;
+	}
+	struct sway_output *output = ws->output;
+	if (!output) {
+		sway_log(SWAY_DEBUG, "Bailing out, no output");
+		return;
+	}
+
+	struct timespec now;
+	clock_gettime(CLOCK_MONOTONIC, &now);
+
+	// Remove expired entries
+	static const int timeout = 60;
+	struct pid_workspace *old, *_old;
+	wl_list_for_each_safe(old, _old, &pid_workspaces, link) {
+		if (now.tv_sec - old->time_added.tv_sec >= timeout) {
+			pid_workspace_destroy(old);
+		}
+	}
+
+	struct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));
+	pw->workspace = strdup(ws->name);
+	pw->output = output;
+	pw->pid = pid;
+	memcpy(&pw->time_added, &now, sizeof(struct timespec));
+	pw->output_destroy.notify = pw_handle_output_destroy;
+	wl_signal_add(&output->wlr_output->events.destroy, &pw->output_destroy);
+	wl_list_insert(&pid_workspaces, &pw->link);
+}
+
+void root_remove_workspace_pid(pid_t pid) {
+	if (!pid_workspaces.prev || !pid_workspaces.next) {
+		return;
+	}
+
+	struct pid_workspace *pw, *tmp;
+	wl_list_for_each_safe(pw, tmp, &pid_workspaces, link) {
+		if (pid == pw->pid) {
+			pid_workspace_destroy(pw);
+			return;
+		}
+	}
+}
+
+void root_rename_pid_workspaces(const char *old_name, const char *new_name) {
+	if (!pid_workspaces.prev && !pid_workspaces.next) {
+		wl_list_init(&pid_workspaces);
+	}
+
+	struct pid_workspace *pw = NULL;
+	wl_list_for_each(pw, &pid_workspaces, link) {
+		if (strcmp(pw->workspace, old_name) == 0) {
+			free(pw->workspace);
+			pw->workspace = strdup(new_name);
+		}
+	}
+}
diff --git a/sway/meson.build b/sway/meson.build
index 1402db1542..2a1a1298d5 100644
--- a/sway/meson.build
+++ b/sway/meson.build
@@ -19,6 +19,7 @@ sway_sources = files(
 	'desktop/surface.c',
 	'desktop/transaction.c',
 	'desktop/xdg_shell.c',
+	'desktop/launcher.c',
 
 	'input/input-manager.c',
 	'input/cursor.c',
diff --git a/sway/tree/root.c b/sway/tree/root.c
index dd4d8e33da..bc3d4bfbda 100644
--- a/sway/tree/root.c
+++ b/sway/tree/root.c
@@ -183,172 +183,6 @@ void root_scratchpad_hide(struct sway_container *con) {
 	ipc_event_window(con, "move");
 }
 
-struct pid_workspace {
-	pid_t pid;
-	char *workspace;
-	struct timespec time_added;
-
-	struct sway_output *output;
-	struct wl_listener output_destroy;
-
-	struct wl_list link;
-};
-
-static struct wl_list pid_workspaces;
-
-/**
- * Get the pid of a parent process given the pid of a child process.
- *
- * Returns the parent pid or NULL if the parent pid cannot be determined.
- */
-static pid_t get_parent_pid(pid_t child) {
-	pid_t parent = -1;
-	char file_name[100];
-	char *buffer = NULL;
-	const char *sep = " ";
-	FILE *stat = NULL;
-	size_t buf_size = 0;
-
-	sprintf(file_name, "/proc/%d/stat", child);
-
-	if ((stat = fopen(file_name, "r"))) {
-		if (getline(&buffer, &buf_size, stat) != -1) {
-			strtok(buffer, sep); // pid
-			strtok(NULL, sep);   // executable name
-			strtok(NULL, sep);   // state
-			char *token = strtok(NULL, sep);   // parent pid
-			parent = strtol(token, NULL, 10);
-		}
-		free(buffer);
-		fclose(stat);
-	}
-
-	if (parent) {
-		return (parent == child) ? -1 : parent;
-	}
-
-	return -1;
-}
-
-static void pid_workspace_destroy(struct pid_workspace *pw) {
-	wl_list_remove(&pw->output_destroy.link);
-	wl_list_remove(&pw->link);
-	free(pw->workspace);
-	free(pw);
-}
-
-struct sway_workspace *root_workspace_for_pid(pid_t pid) {
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
-		return NULL;
-	}
-
-	struct sway_workspace *ws = NULL;
-	struct pid_workspace *pw = NULL;
-
-	sway_log(SWAY_DEBUG, "Looking up workspace for pid %d", pid);
-
-	do {
-		struct pid_workspace *_pw = NULL;
-		wl_list_for_each(_pw, &pid_workspaces, link) {
-			if (pid == _pw->pid) {
-				pw = _pw;
-				sway_log(SWAY_DEBUG,
-						"found pid_workspace for pid %d, workspace %s",
-						pid, pw->workspace);
-				goto found;
-			}
-		}
-		pid = get_parent_pid(pid);
-	} while (pid > 1);
-found:
-
-	if (pw && pw->workspace) {
-		ws = workspace_by_name(pw->workspace);
-
-		if (!ws) {
-			sway_log(SWAY_DEBUG,
-					"Creating workspace %s for pid %d because it disappeared",
-					pw->workspace, pid);
-
-			struct sway_output *output = pw->output;
-			if (pw->output && !pw->output->enabled) {
-				sway_log(SWAY_DEBUG,
-						"Workspace output %s is disabled, trying another one",
-						pw->output->wlr_output->name);
-				output = NULL;
-			}
-
-			ws = workspace_create(output, pw->workspace);
-		}
-
-		pid_workspace_destroy(pw);
-	}
-
-	return ws;
-}
-
-static void pw_handle_output_destroy(struct wl_listener *listener, void *data) {
-	struct pid_workspace *pw = wl_container_of(listener, pw, output_destroy);
-	pw->output = NULL;
-	wl_list_remove(&pw->output_destroy.link);
-	wl_list_init(&pw->output_destroy.link);
-}
-
-void root_record_workspace_pid(pid_t pid) {
-	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
-	}
-
-	struct sway_seat *seat = input_manager_current_seat();
-	struct sway_workspace *ws = seat_get_focused_workspace(seat);
-	if (!ws) {
-		sway_log(SWAY_DEBUG, "Bailing out, no workspace");
-		return;
-	}
-	struct sway_output *output = ws->output;
-	if (!output) {
-		sway_log(SWAY_DEBUG, "Bailing out, no output");
-		return;
-	}
-
-	struct timespec now;
-	clock_gettime(CLOCK_MONOTONIC, &now);
-
-	// Remove expired entries
-	static const int timeout = 60;
-	struct pid_workspace *old, *_old;
-	wl_list_for_each_safe(old, _old, &pid_workspaces, link) {
-		if (now.tv_sec - old->time_added.tv_sec >= timeout) {
-			pid_workspace_destroy(old);
-		}
-	}
-
-	struct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));
-	pw->workspace = strdup(ws->name);
-	pw->output = output;
-	pw->pid = pid;
-	memcpy(&pw->time_added, &now, sizeof(struct timespec));
-	pw->output_destroy.notify = pw_handle_output_destroy;
-	wl_signal_add(&output->wlr_output->events.destroy, &pw->output_destroy);
-	wl_list_insert(&pid_workspaces, &pw->link);
-}
-
-void root_remove_workspace_pid(pid_t pid) {
-	if (!pid_workspaces.prev || !pid_workspaces.next) {
-		return;
-	}
-
-	struct pid_workspace *pw, *tmp;
-	wl_list_for_each_safe(pw, tmp, &pid_workspaces, link) {
-		if (pid == pw->pid) {
-			pid_workspace_destroy(pw);
-			return;
-		}
-	}
-}
-
 void root_for_each_workspace(void (*f)(struct sway_workspace *ws, void *data),
 		void *data) {
 	for (int i = 0; i < root->outputs->length; ++i) {
@@ -443,17 +277,3 @@ void root_get_box(struct sway_root *root, struct wlr_box *box) {
 	box->width = root->width;
 	box->height = root->height;
 }
-
-void root_rename_pid_workspaces(const char *old_name, const char *new_name) {
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
-	}
-
-	struct pid_workspace *pw = NULL;
-	wl_list_for_each(pw, &pid_workspaces, link) {
-		if (strcmp(pw->workspace, old_name) == 0) {
-			free(pw->workspace);
-			pw->workspace = strdup(new_name);
-		}
-	}
-}
diff --git a/sway/tree/view.c b/sway/tree/view.c
index bd53a5c8f4..97205d3643 100644
--- a/sway/tree/view.c
+++ b/sway/tree/view.c
@@ -18,6 +18,7 @@
 #include "sway/desktop.h"
 #include "sway/desktop/transaction.h"
 #include "sway/desktop/idle_inhibit_v1.h"
+#include "sway/desktop/launcher.h"
 #include "sway/input/cursor.h"
 #include "sway/ipc-server.h"
 #include "sway/output.h"

From d6bdd96e516572789a89b34df91ad598e9adbf42 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Mon, 25 Oct 2021 03:58:15 -0700
Subject: [PATCH 04/12] node: prettify node type names

---
 sway/tree/node.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/sway/tree/node.c b/sway/tree/node.c
index bc7e2aa59c..12361c75b4 100644
--- a/sway/tree/node.c
+++ b/sway/tree/node.c
@@ -18,13 +18,13 @@ void node_init(struct sway_node *node, enum sway_node_type type, void *thing) {
 const char *node_type_to_str(enum sway_node_type type) {
 	switch (type) {
 	case N_ROOT:
-		return "N_ROOT";
+		return "root";
 	case N_OUTPUT:
-		return "N_OUTPUT";
+		return "output";
 	case N_WORKSPACE:
-		return "N_WORKSPACE";
+		return "workspace";
 	case N_CONTAINER:
-		return "N_CONTAINER";
+		return "container";
 	}
 	return "";
 }

From 18268a02dcfee80789e03d28a1d82d896e4dafac Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Mon, 25 Oct 2021 18:12:30 -0700
Subject: [PATCH 05/12] launcher: track workspaces by node

This removes the need to rename the pid_workspaces when a workspace
is renamed.

It also opens the possibility of tracking other node types. Tracking
containers would allow application to be placed correctly in the
container tree even if the user has moved their focus elsewhere since
it was launched.
---
 include/sway/desktop/launcher.h |   2 -
 sway/commands/rename.c          |   2 -
 sway/desktop/launcher.c         | 129 +++++++++++++++++++-------------
 3 files changed, 76 insertions(+), 57 deletions(-)

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
index cb22eb9809..bbc4a2c3e2 100644
--- a/include/sway/desktop/launcher.h
+++ b/include/sway/desktop/launcher.h
@@ -9,6 +9,4 @@ void root_record_workspace_pid(pid_t pid);
 
 void root_remove_workspace_pid(pid_t pid);
 
-void root_rename_pid_workspaces(const char *old_name, const char *new_name);
-
 #endif
diff --git a/sway/commands/rename.c b/sway/commands/rename.c
index 4656a41099..60a66d58ad 100644
--- a/sway/commands/rename.c
+++ b/sway/commands/rename.c
@@ -92,8 +92,6 @@ struct cmd_results *cmd_rename(int argc, char **argv) {
 
 	sway_log(SWAY_DEBUG, "renaming workspace '%s' to '%s'", workspace->name, new_name);
 
-	root_rename_pid_workspaces(workspace->name, new_name);
-
 	free(workspace->name);
 	workspace->name = new_name;
 
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index 33eb4be1d7..8dabc06158 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -4,19 +4,21 @@
 #include "sway/input/seat.h"
 #include "sway/output.h"
 #include "sway/desktop/launcher.h"
+#include "sway/tree/node.h"
 #include "sway/tree/container.h"
 #include "sway/tree/workspace.h"
+#include "sway/tree/root.h"
 #include "log.h"
 
 static struct wl_list pid_workspaces;
 
 struct pid_workspace {
 	pid_t pid;
-	char *workspace;
+	char *name;
 	struct timespec time_added;
 
-	struct sway_output *output;
-	struct wl_listener output_destroy;
+	struct sway_node *node;
+	struct wl_listener node_destroy;
 
 	struct wl_list link;
 };
@@ -56,9 +58,9 @@ static pid_t get_parent_pid(pid_t child) {
 }
 
 static void pid_workspace_destroy(struct pid_workspace *pw) {
-	wl_list_remove(&pw->output_destroy.link);
+	wl_list_remove(&pw->node_destroy.link);
 	wl_list_remove(&pw->link);
-	free(pw->workspace);
+	free(pw->name);
 	free(pw);
 }
 
@@ -69,6 +71,7 @@ struct sway_workspace *root_workspace_for_pid(pid_t pid) {
 	}
 
 	struct sway_workspace *ws = NULL;
+	struct sway_output *output = NULL;
 	struct pid_workspace *pw = NULL;
 
 	sway_log(SWAY_DEBUG, "Looking up workspace for pid %d", pid);
@@ -79,45 +82,83 @@ struct sway_workspace *root_workspace_for_pid(pid_t pid) {
 			if (pid == _pw->pid) {
 				pw = _pw;
 				sway_log(SWAY_DEBUG,
-						"found pid_workspace for pid %d, workspace %s",
-						pid, pw->workspace);
-				goto found;
+					"found %s match for pid %d: %s",
+					node_type_to_str(pw->node->type), pid, node_get_name(pw->node));
+				break;
 			}
 		}
 		pid = get_parent_pid(pid);
 	} while (pid > 1);
 
-found:
-	if (pw && pw->workspace) {
-		ws = workspace_by_name(pw->workspace);
-
-		if (!ws) {
-			sway_log(SWAY_DEBUG,
-					"Creating workspace %s for pid %d because it disappeared",
-					pw->workspace, pid);
-
-			struct sway_output *output = pw->output;
-			if (pw->output && !pw->output->enabled) {
+	if (pw) {
+		switch (pw->node->type) {
+		case N_CONTAINER:
+			// Unimplemented
+			// TODO: add container matching?
+			ws = pw->node->sway_container->pending.workspace;
+			break;
+		case N_WORKSPACE:
+			ws = pw->node->sway_workspace;
+			break;
+		case N_OUTPUT:
+			output = pw->node->sway_output;
+			ws = workspace_by_name(pw->name);
+			if (!ws) {
 				sway_log(SWAY_DEBUG,
-						"Workspace output %s is disabled, trying another one",
-						pw->output->wlr_output->name);
-				output = NULL;
+						"Creating workspace %s for pid %d because it disappeared",
+						pw->name, pid);
+				if (!output->enabled) {
+					sway_log(SWAY_DEBUG,
+							"Workspace output %s is disabled, trying another one",
+							output->wlr_output->name);
+					output = NULL;
+				}
+				ws = workspace_create(output, pw->name);
 			}
-
-			ws = workspace_create(output, pw->workspace);
+			break;
+		case N_ROOT:
+			ws = workspace_create(NULL, pw->name);
+			break;
 		}
-
 		pid_workspace_destroy(pw);
 	}
 
 	return ws;
 }
 
-static void pw_handle_output_destroy(struct wl_listener *listener, void *data) {
-	struct pid_workspace *pw = wl_container_of(listener, pw, output_destroy);
-	pw->output = NULL;
-	wl_list_remove(&pw->output_destroy.link);
-	wl_list_init(&pw->output_destroy.link);
+static void pw_handle_node_destroy(struct wl_listener *listener, void *data) {
+	struct pid_workspace *pw = wl_container_of(listener, pw, node_destroy);
+	switch (pw->node->type) {
+	case N_CONTAINER:
+		// Unimplemented
+		break;
+	case N_WORKSPACE:;
+		struct sway_workspace *ws = pw->node->sway_workspace;
+		wl_list_remove(&pw->node_destroy.link);
+		wl_list_init(&pw->node_destroy.link);
+		// We want to save this ws name to recreate later, hopefully on the
+		// same output
+		pw->name = strdup(ws->name);
+		if (!ws->output || ws->output->node.destroying) {
+			// If the output is being destroyed it would be pointless to track
+			// If the output is being disabled, we'll find out if it's still
+			// disabled when we try to match it.
+			pw->node = &root->node;
+			break;
+		}
+		pw->node = &ws->output->node;
+		wl_signal_add(&pw->node->events.destroy, &pw->node_destroy);
+		break;
+	case N_OUTPUT:
+		wl_list_remove(&pw->node_destroy.link);
+		wl_list_init(&pw->node_destroy.link);
+		// We'll make the ws pw->name somewhere else
+		pw->node = &root->node;
+		break;
+	case N_ROOT:
+		// Unreachable
+		break;
+	}
 }
 
 void root_record_workspace_pid(pid_t pid) {
@@ -132,11 +173,6 @@ void root_record_workspace_pid(pid_t pid) {
 		sway_log(SWAY_DEBUG, "Bailing out, no workspace");
 		return;
 	}
-	struct sway_output *output = ws->output;
-	if (!output) {
-		sway_log(SWAY_DEBUG, "Bailing out, no output");
-		return;
-	}
 
 	struct timespec now;
 	clock_gettime(CLOCK_MONOTONIC, &now);
@@ -151,12 +187,13 @@ void root_record_workspace_pid(pid_t pid) {
 	}
 
 	struct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));
-	pw->workspace = strdup(ws->name);
-	pw->output = output;
+	pw->name = strdup(ws->name);
+	pw->node = &ws->node;
 	pw->pid = pid;
+
 	memcpy(&pw->time_added, &now, sizeof(struct timespec));
-	pw->output_destroy.notify = pw_handle_output_destroy;
-	wl_signal_add(&output->wlr_output->events.destroy, &pw->output_destroy);
+	pw->node_destroy.notify = pw_handle_node_destroy;
+	wl_signal_add(&pw->node->events.destroy, &pw->node_destroy);
 	wl_list_insert(&pid_workspaces, &pw->link);
 }
 
@@ -173,17 +210,3 @@ void root_remove_workspace_pid(pid_t pid) {
 		}
 	}
 }
-
-void root_rename_pid_workspaces(const char *old_name, const char *new_name) {
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
-	}
-
-	struct pid_workspace *pw = NULL;
-	wl_list_for_each(pw, &pid_workspaces, link) {
-		if (strcmp(pw->workspace, old_name) == 0) {
-			free(pw->workspace);
-			pw->workspace = strdup(new_name);
-		}
-	}
-}

From 5078fa18d3a7785f6abcecf4a979b29a731d6ea3 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Mon, 25 Oct 2021 22:55:44 -0700
Subject: [PATCH 06/12] launcher: use xdga tokens

This reuses wlroots token tracking for workspace matching. It doesn't
export any xdga tokens for clients yet.
---
 sway/desktop/launcher.c | 33 +++++++++++++++++++--------------
 1 file changed, 19 insertions(+), 14 deletions(-)

diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index 8dabc06158..08ded1b71f 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -1,6 +1,7 @@
 #define _POSIX_C_SOURCE 200809L
 #include <stdlib.h>
 #include <string.h>
+#include <wlr/types/wlr_xdg_activation_v1.h>
 #include "sway/input/seat.h"
 #include "sway/output.h"
 #include "sway/desktop/launcher.h"
@@ -15,7 +16,8 @@ static struct wl_list pid_workspaces;
 struct pid_workspace {
 	pid_t pid;
 	char *name;
-	struct timespec time_added;
+	struct wlr_xdg_activation_token_v1 *token;
+	struct wl_listener token_destroy;
 
 	struct sway_node *node;
 	struct wl_listener node_destroy;
@@ -59,7 +61,9 @@ static pid_t get_parent_pid(pid_t child) {
 
 static void pid_workspace_destroy(struct pid_workspace *pw) {
 	wl_list_remove(&pw->node_destroy.link);
+	wl_list_remove(&pw->token_destroy.link);
 	wl_list_remove(&pw->link);
+	wlr_xdg_activation_token_v1_destroy(pw->token);
 	free(pw->name);
 	free(pw);
 }
@@ -161,6 +165,12 @@ static void pw_handle_node_destroy(struct wl_listener *listener, void *data) {
 	}
 }
 
+static void token_handle_destroy(struct wl_listener *listener, void *data) {
+	struct pid_workspace *pw = wl_container_of(listener, pw, token_destroy);
+	pw->token = NULL;
+	pid_workspace_destroy(pw);
+}
+
 void root_record_workspace_pid(pid_t pid) {
 	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
 	if (!pid_workspaces.prev && !pid_workspaces.next) {
@@ -174,26 +184,21 @@ void root_record_workspace_pid(pid_t pid) {
 		return;
 	}
 
-	struct timespec now;
-	clock_gettime(CLOCK_MONOTONIC, &now);
-
-	// Remove expired entries
-	static const int timeout = 60;
-	struct pid_workspace *old, *_old;
-	wl_list_for_each_safe(old, _old, &pid_workspaces, link) {
-		if (now.tv_sec - old->time_added.tv_sec >= timeout) {
-			pid_workspace_destroy(old);
-		}
-	}
-
 	struct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));
+	struct wlr_xdg_activation_token_v1 *token =
+		wlr_xdg_activation_token_v1_create(server.xdg_activation_v1);
+	token->data = pw;
 	pw->name = strdup(ws->name);
+	pw->token = token;
 	pw->node = &ws->node;
 	pw->pid = pid;
 
-	memcpy(&pw->time_added, &now, sizeof(struct timespec));
 	pw->node_destroy.notify = pw_handle_node_destroy;
 	wl_signal_add(&pw->node->events.destroy, &pw->node_destroy);
+
+	pw->token_destroy.notify = token_handle_destroy;
+	wl_signal_add(&token->events.destroy, &pw->token_destroy);
+
 	wl_list_insert(&pid_workspaces, &pw->link);
 }
 

From ee5cd95bfcf236e800f8af2885916a77ac75d49c Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Wed, 27 Oct 2021 21:20:41 -0700
Subject: [PATCH 07/12] launcher: rename pid_workspace to launcher_ctx

Soon we will match views with more than just a pid.
---
 include/sway/desktop/launcher.h |   6 +-
 sway/commands/exec_always.c     |   2 +-
 sway/desktop/launcher.c         | 188 +++++++++++++++++---------------
 sway/tree/view.c                |   4 +-
 4 files changed, 105 insertions(+), 95 deletions(-)

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
index bbc4a2c3e2..7802bee15b 100644
--- a/include/sway/desktop/launcher.h
+++ b/include/sway/desktop/launcher.h
@@ -3,10 +3,10 @@
 
 #include <stdlib.h>
 
-struct sway_workspace *root_workspace_for_pid(pid_t pid);
+struct sway_workspace *workspace_for_pid(pid_t pid);
 
-void root_record_workspace_pid(pid_t pid);
+void launcher_ctx_create(pid_t pid);
 
-void root_remove_workspace_pid(pid_t pid);
+void remove_workspace_pid(pid_t pid);
 
 #endif
diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index fab9a4028f..d67e416fa1 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -91,7 +91,7 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	waitpid(pid, NULL, 0);
 	if (child > 0) {
 		sway_log(SWAY_DEBUG, "Child process created with pid %d", child);
-		root_record_workspace_pid(child);
+		launcher_ctx_create(child);
 	} else {
 		return cmd_results_new(CMD_FAILURE, "Second fork() failed");
 	}
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index 08ded1b71f..c8b8877556 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -11,9 +11,9 @@
 #include "sway/tree/root.h"
 #include "log.h"
 
-static struct wl_list pid_workspaces;
+static struct wl_list launcher_ctxs;
 
-struct pid_workspace {
+struct launcher_ctx {
 	pid_t pid;
 	char *name;
 	struct wlr_xdg_activation_token_v1 *token;
@@ -59,105 +59,120 @@ static pid_t get_parent_pid(pid_t child) {
 	return -1;
 }
 
-static void pid_workspace_destroy(struct pid_workspace *pw) {
-	wl_list_remove(&pw->node_destroy.link);
-	wl_list_remove(&pw->token_destroy.link);
-	wl_list_remove(&pw->link);
-	wlr_xdg_activation_token_v1_destroy(pw->token);
-	free(pw->name);
-	free(pw);
+static void launcher_ctx_destroy(struct launcher_ctx *ctx) {
+	if (ctx == NULL) {
+		return;
+	}
+	wl_list_remove(&ctx->node_destroy.link);
+	wl_list_remove(&ctx->token_destroy.link);
+	wl_list_remove(&ctx->link);
+	wlr_xdg_activation_token_v1_destroy(ctx->token);
+	free(ctx->name);
+	free(ctx);
 }
 
-struct sway_workspace *root_workspace_for_pid(pid_t pid) {
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
+static struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
+	if (!launcher_ctxs.prev && !launcher_ctxs.next) {
+		wl_list_init(&launcher_ctxs);
 		return NULL;
 	}
 
-	struct sway_workspace *ws = NULL;
-	struct sway_output *output = NULL;
-	struct pid_workspace *pw = NULL;
-
+	struct launcher_ctx *ctx = NULL;
 	sway_log(SWAY_DEBUG, "Looking up workspace for pid %d", pid);
 
 	do {
-		struct pid_workspace *_pw = NULL;
-		wl_list_for_each(_pw, &pid_workspaces, link) {
-			if (pid == _pw->pid) {
-				pw = _pw;
+		struct launcher_ctx *_ctx = NULL;
+		wl_list_for_each(_ctx, &launcher_ctxs, link) {
+			if (pid == _ctx->pid) {
+				ctx = _ctx;
 				sway_log(SWAY_DEBUG,
 					"found %s match for pid %d: %s",
-					node_type_to_str(pw->node->type), pid, node_get_name(pw->node));
+					node_type_to_str(ctx->node->type), pid, node_get_name(ctx->node));
 				break;
 			}
 		}
 		pid = get_parent_pid(pid);
 	} while (pid > 1);
 
-	if (pw) {
-		switch (pw->node->type) {
-		case N_CONTAINER:
-			// Unimplemented
-			// TODO: add container matching?
-			ws = pw->node->sway_container->pending.workspace;
-			break;
-		case N_WORKSPACE:
-			ws = pw->node->sway_workspace;
-			break;
-		case N_OUTPUT:
-			output = pw->node->sway_output;
-			ws = workspace_by_name(pw->name);
-			if (!ws) {
+	return ctx;
+}
+
+static struct sway_workspace *launcher_ctx_get_workspace(
+		struct launcher_ctx *ctx) {
+	struct sway_workspace *ws = NULL;
+	struct sway_output *output = NULL;
+
+	switch (ctx->node->type) {
+	case N_CONTAINER:
+		// Unimplemented
+		// TODO: add container matching?
+		ws = ctx->node->sway_container->pending.workspace;
+		break;
+	case N_WORKSPACE:
+		ws = ctx->node->sway_workspace;
+		break;
+	case N_OUTPUT:
+		output = ctx->node->sway_output;
+		ws = workspace_by_name(ctx->name);
+		if (!ws) {
+			sway_log(SWAY_DEBUG,
+					"Creating workspace %s for pid %d because it disappeared",
+					ctx->name, ctx->pid);
+			if (!output->enabled) {
 				sway_log(SWAY_DEBUG,
-						"Creating workspace %s for pid %d because it disappeared",
-						pw->name, pid);
-				if (!output->enabled) {
-					sway_log(SWAY_DEBUG,
-							"Workspace output %s is disabled, trying another one",
-							output->wlr_output->name);
-					output = NULL;
-				}
-				ws = workspace_create(output, pw->name);
+						"Workspace output %s is disabled, trying another one",
+						output->wlr_output->name);
+				output = NULL;
 			}
-			break;
-		case N_ROOT:
-			ws = workspace_create(NULL, pw->name);
-			break;
+			ws = workspace_create(output, ctx->name);
 		}
-		pid_workspace_destroy(pw);
+		break;
+	case N_ROOT:
+		ws = workspace_create(NULL, ctx->name);
+		break;
 	}
 
 	return ws;
 }
 
-static void pw_handle_node_destroy(struct wl_listener *listener, void *data) {
-	struct pid_workspace *pw = wl_container_of(listener, pw, node_destroy);
-	switch (pw->node->type) {
+struct sway_workspace *workspace_for_pid(pid_t pid) {
+	struct launcher_ctx *ctx = launcher_ctx_find_pid(pid);
+	if (ctx == NULL) {
+		return NULL;
+	}
+	struct sway_workspace *ws = launcher_ctx_get_workspace(ctx);
+	launcher_ctx_destroy(ctx);
+	return ws;
+}
+
+static void ctx_handle_node_destroy(struct wl_listener *listener, void *data) {
+	struct launcher_ctx *ctx = wl_container_of(listener, ctx, node_destroy);
+	switch (ctx->node->type) {
 	case N_CONTAINER:
 		// Unimplemented
 		break;
 	case N_WORKSPACE:;
-		struct sway_workspace *ws = pw->node->sway_workspace;
-		wl_list_remove(&pw->node_destroy.link);
-		wl_list_init(&pw->node_destroy.link);
+		struct sway_workspace *ws = ctx->node->sway_workspace;
+		wl_list_remove(&ctx->node_destroy.link);
+		wl_list_init(&ctx->node_destroy.link);
 		// We want to save this ws name to recreate later, hopefully on the
 		// same output
-		pw->name = strdup(ws->name);
+		ctx->name = strdup(ws->name);
 		if (!ws->output || ws->output->node.destroying) {
 			// If the output is being destroyed it would be pointless to track
 			// If the output is being disabled, we'll find out if it's still
 			// disabled when we try to match it.
-			pw->node = &root->node;
+			ctx->node = &root->node;
 			break;
 		}
-		pw->node = &ws->output->node;
-		wl_signal_add(&pw->node->events.destroy, &pw->node_destroy);
+		ctx->node = &ws->output->node;
+		wl_signal_add(&ctx->node->events.destroy, &ctx->node_destroy);
 		break;
 	case N_OUTPUT:
-		wl_list_remove(&pw->node_destroy.link);
-		wl_list_init(&pw->node_destroy.link);
-		// We'll make the ws pw->name somewhere else
-		pw->node = &root->node;
+		wl_list_remove(&ctx->node_destroy.link);
+		wl_list_init(&ctx->node_destroy.link);
+		// We'll make the ws ctx->name somewhere else
+		ctx->node = &root->node;
 		break;
 	case N_ROOT:
 		// Unreachable
@@ -166,15 +181,15 @@ static void pw_handle_node_destroy(struct wl_listener *listener, void *data) {
 }
 
 static void token_handle_destroy(struct wl_listener *listener, void *data) {
-	struct pid_workspace *pw = wl_container_of(listener, pw, token_destroy);
-	pw->token = NULL;
-	pid_workspace_destroy(pw);
+	struct launcher_ctx *ctx = wl_container_of(listener, ctx, token_destroy);
+	ctx->token = NULL;
+	launcher_ctx_destroy(ctx);
 }
 
-void root_record_workspace_pid(pid_t pid) {
+void launcher_ctx_create(pid_t pid) {
 	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
-	if (!pid_workspaces.prev && !pid_workspaces.next) {
-		wl_list_init(&pid_workspaces);
+	if (!launcher_ctxs.prev && !launcher_ctxs.next) {
+		wl_list_init(&launcher_ctxs);
 	}
 
 	struct sway_seat *seat = input_manager_current_seat();
@@ -184,34 +199,29 @@ void root_record_workspace_pid(pid_t pid) {
 		return;
 	}
 
-	struct pid_workspace *pw = calloc(1, sizeof(struct pid_workspace));
+	struct launcher_ctx *ctx = calloc(1, sizeof(struct launcher_ctx));
 	struct wlr_xdg_activation_token_v1 *token =
 		wlr_xdg_activation_token_v1_create(server.xdg_activation_v1);
-	token->data = pw;
-	pw->name = strdup(ws->name);
-	pw->token = token;
-	pw->node = &ws->node;
-	pw->pid = pid;
+	token->data = ctx;
+	ctx->name = strdup(ws->name);
+	ctx->token = token;
+	ctx->node = &ws->node;
+	ctx->pid = pid;
 
-	pw->node_destroy.notify = pw_handle_node_destroy;
-	wl_signal_add(&pw->node->events.destroy, &pw->node_destroy);
+	ctx->node_destroy.notify = ctx_handle_node_destroy;
+	wl_signal_add(&ctx->node->events.destroy, &ctx->node_destroy);
 
-	pw->token_destroy.notify = token_handle_destroy;
-	wl_signal_add(&token->events.destroy, &pw->token_destroy);
+	ctx->token_destroy.notify = token_handle_destroy;
+	wl_signal_add(&token->events.destroy, &ctx->token_destroy);
 
-	wl_list_insert(&pid_workspaces, &pw->link);
+	wl_list_insert(&launcher_ctxs, &ctx->link);
 }
 
-void root_remove_workspace_pid(pid_t pid) {
-	if (!pid_workspaces.prev || !pid_workspaces.next) {
+void remove_workspace_pid(pid_t pid) {
+	if (!launcher_ctxs.prev || !launcher_ctxs.next) {
 		return;
 	}
 
-	struct pid_workspace *pw, *tmp;
-	wl_list_for_each_safe(pw, tmp, &pid_workspaces, link) {
-		if (pid == pw->pid) {
-			pid_workspace_destroy(pw);
-			return;
-		}
-	}
+	struct launcher_ctx *ctx = launcher_ctx_find_pid(pid);
+	launcher_ctx_destroy(ctx);
 }
diff --git a/sway/tree/view.c b/sway/tree/view.c
index 97205d3643..fbdcd9546a 100644
--- a/sway/tree/view.c
+++ b/sway/tree/view.c
@@ -568,12 +568,12 @@ static struct sway_workspace *select_workspace(struct sway_view *view) {
 	}
 	list_free(criterias);
 	if (ws) {
-		root_remove_workspace_pid(view->pid);
+		remove_workspace_pid(view->pid);
 		return ws;
 	}
 
 	// Check if there's a PID mapping
-	ws = root_workspace_for_pid(view->pid);
+	ws = workspace_for_pid(view->pid);
 	if (ws) {
 		return ws;
 	}

From 1673e27c91d20fa9b533711e0d910e59b6b21c93 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Wed, 27 Oct 2021 21:29:20 -0700
Subject: [PATCH 08/12] view: associate launch contexts with views

Views now maintain a reference to a launch context which, as a last
resort, is populated at map time with a context associated with its pid.
This opens the possibility of populating it before map via another
source, e.g. xdga-tokens or configuration.
---
 include/sway/desktop/launcher.h | 22 ++++++++++++++++---
 include/sway/tree/view.h        |  3 +++
 sway/desktop/launcher.c         | 38 ++++++---------------------------
 sway/tree/view.c                | 34 +++++++++++++++++++++++++++--
 4 files changed, 60 insertions(+), 37 deletions(-)

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
index 7802bee15b..c64c895188 100644
--- a/include/sway/desktop/launcher.h
+++ b/include/sway/desktop/launcher.h
@@ -3,10 +3,26 @@
 
 #include <stdlib.h>
 
-struct sway_workspace *workspace_for_pid(pid_t pid);
+struct launcher_ctx {
+	pid_t pid;
+	char *name;
+	struct wlr_xdg_activation_token_v1 *token;
+	struct wl_listener token_destroy;
 
-void launcher_ctx_create(pid_t pid);
+	struct sway_node *node;
+	struct wl_listener node_destroy;
+
+	struct wl_list link;
+};
+
+struct launcher_ctx *launcher_ctx_find_pid(pid_t pid);
+
+struct sway_workspace *launcher_ctx_get_workspace(struct launcher_ctx *ctx);
 
-void remove_workspace_pid(pid_t pid);
+void launcher_ctx_destroy(struct launcher_ctx *ctx);
+
+const char *launcher_ctx_get_name(struct launcher_ctx *ctx);
+
+void launcher_ctx_create(pid_t pid);
 
 #endif
diff --git a/include/sway/tree/view.h b/include/sway/tree/view.h
index 008361f7b3..b61d612fd5 100644
--- a/include/sway/tree/view.h
+++ b/include/sway/tree/view.h
@@ -74,6 +74,7 @@ struct sway_view {
 	struct sway_xdg_decoration *xdg_decoration;
 
 	pid_t pid;
+	struct launcher_ctx *ctx;
 
 	// The size the view would want to be if it weren't tiled.
 	// Used when changing a view from tiled to floating.
@@ -370,4 +371,6 @@ void view_save_buffer(struct sway_view *view);
 
 bool view_is_transient_for(struct sway_view *child, struct sway_view *ancestor);
 
+void view_assign_ctx(struct sway_view *view, struct launcher_ctx *ctx);
+
 #endif
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index c8b8877556..8f59808dda 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -13,18 +13,6 @@
 
 static struct wl_list launcher_ctxs;
 
-struct launcher_ctx {
-	pid_t pid;
-	char *name;
-	struct wlr_xdg_activation_token_v1 *token;
-	struct wl_listener token_destroy;
-
-	struct sway_node *node;
-	struct wl_listener node_destroy;
-
-	struct wl_list link;
-};
-
 /**
  * Get the pid of a parent process given the pid of a child process.
  *
@@ -59,7 +47,7 @@ static pid_t get_parent_pid(pid_t child) {
 	return -1;
 }
 
-static void launcher_ctx_destroy(struct launcher_ctx *ctx) {
+void launcher_ctx_destroy(struct launcher_ctx *ctx) {
 	if (ctx == NULL) {
 		return;
 	}
@@ -71,7 +59,7 @@ static void launcher_ctx_destroy(struct launcher_ctx *ctx) {
 	free(ctx);
 }
 
-static struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
+struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
 	if (!launcher_ctxs.prev && !launcher_ctxs.next) {
 		wl_list_init(&launcher_ctxs);
 		return NULL;
@@ -97,7 +85,7 @@ static struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
 	return ctx;
 }
 
-static struct sway_workspace *launcher_ctx_get_workspace(
+struct sway_workspace *launcher_ctx_get_workspace(
 		struct launcher_ctx *ctx) {
 	struct sway_workspace *ws = NULL;
 	struct sway_output *output = NULL;
@@ -135,16 +123,6 @@ static struct sway_workspace *launcher_ctx_get_workspace(
 	return ws;
 }
 
-struct sway_workspace *workspace_for_pid(pid_t pid) {
-	struct launcher_ctx *ctx = launcher_ctx_find_pid(pid);
-	if (ctx == NULL) {
-		return NULL;
-	}
-	struct sway_workspace *ws = launcher_ctx_get_workspace(ctx);
-	launcher_ctx_destroy(ctx);
-	return ws;
-}
-
 static void ctx_handle_node_destroy(struct wl_listener *listener, void *data) {
 	struct launcher_ctx *ctx = wl_container_of(listener, ctx, node_destroy);
 	switch (ctx->node->type) {
@@ -217,11 +195,7 @@ void launcher_ctx_create(pid_t pid) {
 	wl_list_insert(&launcher_ctxs, &ctx->link);
 }
 
-void remove_workspace_pid(pid_t pid) {
-	if (!launcher_ctxs.prev || !launcher_ctxs.next) {
-		return;
-	}
-
-	struct launcher_ctx *ctx = launcher_ctx_find_pid(pid);
-	launcher_ctx_destroy(ctx);
+const char *launcher_ctx_get_name(struct launcher_ctx *ctx) {
+	const char *token = wlr_xdg_activation_token_v1_get_name(ctx->token);
+	return token;
 }
diff --git a/sway/tree/view.c b/sway/tree/view.c
index fbdcd9546a..1840180093 100644
--- a/sway/tree/view.c
+++ b/sway/tree/view.c
@@ -63,6 +63,8 @@ void view_destroy(struct sway_view *view) {
 	}
 	list_free(view->executed_criteria);
 
+	view_assign_ctx(view, NULL);
+
 	free(view->title_format);
 
 	if (view->impl->destroy) {
@@ -533,6 +535,26 @@ static void view_populate_pid(struct sway_view *view) {
 	view->pid = pid;
 }
 
+void view_assign_ctx(struct sway_view *view, struct launcher_ctx *ctx) {
+	if (view->ctx) {
+		// This ctx has been replaced
+		launcher_ctx_destroy(view->ctx);
+		view->ctx = NULL;
+	}
+	if (ctx == NULL) {
+		return;
+	}
+	ctx->token = NULL; // token is consumed
+	wl_list_remove(&ctx->link); // ctx is consumed
+	wl_list_init(&ctx->link);
+
+	// View is now responsible for destroying this
+	wl_list_remove(&ctx->token_destroy.link);
+	wl_list_init(&ctx->token_destroy.link);
+
+	view->ctx = ctx;
+}
+
 static struct sway_workspace *select_workspace(struct sway_view *view) {
 	struct sway_seat *seat = input_manager_current_seat();
 
@@ -568,13 +590,14 @@ static struct sway_workspace *select_workspace(struct sway_view *view) {
 	}
 	list_free(criterias);
 	if (ws) {
-		remove_workspace_pid(view->pid);
+		view_assign_ctx(view, NULL);
 		return ws;
 	}
 
 	// Check if there's a PID mapping
-	ws = workspace_for_pid(view->pid);
+	ws = view->ctx ? launcher_ctx_get_workspace(view->ctx) : NULL;
 	if (ws) {
+		view_assign_ctx(view, NULL);
 		return ws;
 	}
 
@@ -717,6 +740,13 @@ void view_map(struct sway_view *view, struct wlr_surface *wlr_surface,
 	view_populate_pid(view);
 	view->container = container_create(view);
 
+	if (view->ctx == NULL) {
+		struct launcher_ctx *ctx = launcher_ctx_find_pid(view->pid);
+		if (ctx != NULL) {
+			view_assign_ctx(view, ctx);
+		}
+	}
+
 	// If there is a request to be opened fullscreen on a specific output, try
 	// to honor that request. Otherwise, fallback to assigns, pid mappings,
 	// focused workspace, etc

From b28af4c52c8e9bc8aea57d690f5eb44910d6565d Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Wed, 27 Oct 2021 21:34:42 -0700
Subject: [PATCH 09/12] launcher: initialize launcher_ctxs once on startup

---
 include/sway/desktop/launcher.h |  2 +-
 include/sway/server.h           |  2 ++
 sway/commands/exec_always.c     |  6 +++++-
 sway/desktop/launcher.c         | 17 ++++++-----------
 sway/server.c                   |  2 ++
 5 files changed, 16 insertions(+), 13 deletions(-)

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
index c64c895188..39084d3082 100644
--- a/include/sway/desktop/launcher.h
+++ b/include/sway/desktop/launcher.h
@@ -23,6 +23,6 @@ void launcher_ctx_destroy(struct launcher_ctx *ctx);
 
 const char *launcher_ctx_get_name(struct launcher_ctx *ctx);
 
-void launcher_ctx_create(pid_t pid);
+struct launcher_ctx *launcher_ctx_create(pid_t pid);
 
 #endif
diff --git a/include/sway/server.h b/include/sway/server.h
index f99bbda679..fa5a1a54d0 100644
--- a/include/sway/server.h
+++ b/include/sway/server.h
@@ -94,6 +94,8 @@ struct sway_server {
 	struct wlr_xdg_activation_v1 *xdg_activation_v1;
 	struct wl_listener xdg_activation_v1_request_activate;
 
+	struct wl_list launcher_ctxs; // launcher_ctx::link
+
 	// The timeout for transactions, after which a transaction is applied
 	// regardless of readiness.
 	size_t txn_timeout_ms;
diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index d67e416fa1..dd8dc2f6b0 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -9,6 +9,7 @@
 #include "sway/config.h"
 #include "sway/server.h"
 #include "sway/desktop/launcher.h"
+#include "sway/server.h"
 #include "sway/tree/container.h"
 #include "sway/tree/root.h"
 #include "sway/tree/workspace.h"
@@ -91,7 +92,10 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	waitpid(pid, NULL, 0);
 	if (child > 0) {
 		sway_log(SWAY_DEBUG, "Child process created with pid %d", child);
-		launcher_ctx_create(child);
+		struct launcher_ctx *ctx = launcher_ctx_create(child);
+		if (ctx != NULL) {
+			wl_list_insert(&server.launcher_ctxs, &ctx->link);
+		}
 	} else {
 		return cmd_results_new(CMD_FAILURE, "Second fork() failed");
 	}
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index 8f59808dda..ed4e0e6088 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -11,8 +11,6 @@
 #include "sway/tree/root.h"
 #include "log.h"
 
-static struct wl_list launcher_ctxs;
-
 /**
  * Get the pid of a parent process given the pid of a child process.
  *
@@ -60,8 +58,7 @@ void launcher_ctx_destroy(struct launcher_ctx *ctx) {
 }
 
 struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
-	if (!launcher_ctxs.prev && !launcher_ctxs.next) {
-		wl_list_init(&launcher_ctxs);
+	if (wl_list_empty(&server.launcher_ctxs)) {
 		return NULL;
 	}
 
@@ -70,7 +67,7 @@ struct launcher_ctx *launcher_ctx_find_pid(pid_t pid) {
 
 	do {
 		struct launcher_ctx *_ctx = NULL;
-		wl_list_for_each(_ctx, &launcher_ctxs, link) {
+		wl_list_for_each(_ctx, &server.launcher_ctxs, link) {
 			if (pid == _ctx->pid) {
 				ctx = _ctx;
 				sway_log(SWAY_DEBUG,
@@ -164,17 +161,14 @@ static void token_handle_destroy(struct wl_listener *listener, void *data) {
 	launcher_ctx_destroy(ctx);
 }
 
-void launcher_ctx_create(pid_t pid) {
+struct launcher_ctx *launcher_ctx_create(pid_t pid) {
 	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
-	if (!launcher_ctxs.prev && !launcher_ctxs.next) {
-		wl_list_init(&launcher_ctxs);
-	}
 
 	struct sway_seat *seat = input_manager_current_seat();
 	struct sway_workspace *ws = seat_get_focused_workspace(seat);
 	if (!ws) {
 		sway_log(SWAY_DEBUG, "Bailing out, no workspace");
-		return;
+		return NULL;
 	}
 
 	struct launcher_ctx *ctx = calloc(1, sizeof(struct launcher_ctx));
@@ -192,7 +186,8 @@ void launcher_ctx_create(pid_t pid) {
 	ctx->token_destroy.notify = token_handle_destroy;
 	wl_signal_add(&token->events.destroy, &ctx->token_destroy);
 
-	wl_list_insert(&launcher_ctxs, &ctx->link);
+	wl_list_init(&ctx->link);
+	return ctx;
 }
 
 const char *launcher_ctx_get_name(struct launcher_ctx *ctx) {
diff --git a/sway/server.c b/sway/server.c
index b187fcd528..073d739031 100644
--- a/sway/server.c
+++ b/sway/server.c
@@ -190,6 +190,8 @@ bool server_init(struct sway_server *server) {
 	wl_signal_add(&server->xdg_activation_v1->events.request_activate,
 		&server->xdg_activation_v1_request_activate);
 
+	wl_list_init(&server->launcher_ctxs);
+
 	// Avoid using "wayland-0" as display socket
 	char name_candidate[16];
 	for (int i = 1; i <= 32; ++i) {

From 3114a6ded9ce0df3d59066adae459f150386a874 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Tue, 26 Oct 2021 16:38:31 -0700
Subject: [PATCH 10/12] launcher: fudge the interface a bit

We want to create a context before knowing the pid it will match with.
---
 include/sway/desktop/launcher.h | 2 +-
 sway/commands/exec_always.c     | 5 ++++-
 sway/desktop/launcher.c         | 7 ++-----
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/include/sway/desktop/launcher.h b/include/sway/desktop/launcher.h
index 39084d3082..8b006ccaf7 100644
--- a/include/sway/desktop/launcher.h
+++ b/include/sway/desktop/launcher.h
@@ -23,6 +23,6 @@ void launcher_ctx_destroy(struct launcher_ctx *ctx);
 
 const char *launcher_ctx_get_name(struct launcher_ctx *ctx);
 
-struct launcher_ctx *launcher_ctx_create(pid_t pid);
+struct launcher_ctx *launcher_ctx_create();
 
 #endif
diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index dd8dc2f6b0..694f646c13 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -53,6 +53,7 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	}
 
 	pid_t pid, child;
+	struct launcher_ctx *ctx = launcher_ctx_create();
 	// Fork process
 	if ((pid = fork()) == 0) {
 		// Fork child process again
@@ -92,11 +93,13 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	waitpid(pid, NULL, 0);
 	if (child > 0) {
 		sway_log(SWAY_DEBUG, "Child process created with pid %d", child);
-		struct launcher_ctx *ctx = launcher_ctx_create(child);
 		if (ctx != NULL) {
+			sway_log(SWAY_DEBUG, "Recording workspace for process %d", child);
+			ctx->pid = child;
 			wl_list_insert(&server.launcher_ctxs, &ctx->link);
 		}
 	} else {
+		launcher_ctx_destroy(ctx);
 		return cmd_results_new(CMD_FAILURE, "Second fork() failed");
 	}
 
diff --git a/sway/desktop/launcher.c b/sway/desktop/launcher.c
index ed4e0e6088..0835f1dfc5 100644
--- a/sway/desktop/launcher.c
+++ b/sway/desktop/launcher.c
@@ -161,13 +161,11 @@ static void token_handle_destroy(struct wl_listener *listener, void *data) {
 	launcher_ctx_destroy(ctx);
 }
 
-struct launcher_ctx *launcher_ctx_create(pid_t pid) {
-	sway_log(SWAY_DEBUG, "Recording workspace for process %d", pid);
-
+struct launcher_ctx *launcher_ctx_create() {
 	struct sway_seat *seat = input_manager_current_seat();
 	struct sway_workspace *ws = seat_get_focused_workspace(seat);
 	if (!ws) {
-		sway_log(SWAY_DEBUG, "Bailing out, no workspace");
+		sway_log(SWAY_DEBUG, "Failed to create launch context. No workspace.");
 		return NULL;
 	}
 
@@ -178,7 +176,6 @@ struct launcher_ctx *launcher_ctx_create(pid_t pid) {
 	ctx->name = strdup(ws->name);
 	ctx->token = token;
 	ctx->node = &ws->node;
-	ctx->pid = pid;
 
 	ctx->node_destroy.notify = ctx_handle_node_destroy;
 	wl_signal_add(&ctx->node->events.destroy, &ctx->node_destroy);

From 07f39235c53bfaba178246484efaac93f799f1c2 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Wed, 27 Oct 2021 23:02:34 -0700
Subject: [PATCH 11/12] launcher: export xdga tokens and use them for workspace
 matching

---
 sway/commands/exec_always.c |  6 ++++++
 sway/xdg_activation_v1.c    | 11 ++++++++++-
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index 694f646c13..e432c463bc 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -27,6 +27,11 @@ struct cmd_results *cmd_exec_validate(int argc, char **argv) {
 	return error;
 }
 
+static void export_xdga_token(struct launcher_ctx *ctx) {
+	const char *token = launcher_ctx_get_name(ctx);
+	setenv("XDG_ACTIVATION_TOKEN", token, 1);
+}
+
 struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	struct cmd_results *error = NULL;
 	char *cmd = NULL;
@@ -66,6 +71,7 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 		close(fd[0]);
 		if ((child = fork()) == 0) {
 			close(fd[1]);
+			export_xdga_token(ctx);
 			execlp("sh", "sh", "-c", cmd, (void *)NULL);
 			sway_log_errno(SWAY_ERROR, "execlp failed");
 			_exit(1);
diff --git a/sway/xdg_activation_v1.c b/sway/xdg_activation_v1.c
index 6c70c78596..e1776e7dbc 100644
--- a/sway/xdg_activation_v1.c
+++ b/sway/xdg_activation_v1.c
@@ -1,4 +1,5 @@
 #include <wlr/types/wlr_xdg_activation_v1.h>
+#include "sway/desktop/launcher.h"
 #include "sway/tree/view.h"
 
 void xdg_activation_v1_handle_request_activate(struct wl_listener *listener,
@@ -12,7 +13,15 @@ void xdg_activation_v1_handle_request_activate(struct wl_listener *listener,
 	struct wlr_xdg_surface *xdg_surface =
 		wlr_xdg_surface_from_wlr_surface(event->surface);
 	struct sway_view *view = xdg_surface->data;
-	if (!xdg_surface->mapped || view == NULL) {
+	if (view == NULL) {
+		return;
+	}
+
+	if (!xdg_surface->mapped) {
+		// This is a startup notification. If we are tracking it, the data
+		// field is a launcher_ctx.
+		struct launcher_ctx *ctx = event->token->data;
+		view_assign_ctx(view, ctx);
 		return;
 	}
 

From 7ae1a6a81479fda7f67a17adc820a7c3c5927a43 Mon Sep 17 00:00:00 2001
From: Ronan Pigott <rpigott@berkeley.edu>
Date: Fri, 29 Oct 2021 15:56:47 -0700
Subject: [PATCH 12/12] launcher: export X startup ids and use them for
 workspace matching

---
 include/sway/tree/view.h    |  1 +
 sway/commands/exec_always.c | 11 ++++++++++-
 sway/desktop/xwayland.c     | 28 ++++++++++++++++++++++++++++
 3 files changed, 39 insertions(+), 1 deletion(-)

diff --git a/include/sway/tree/view.h b/include/sway/tree/view.h
index b61d612fd5..1288a4988d 100644
--- a/include/sway/tree/view.h
+++ b/include/sway/tree/view.h
@@ -155,6 +155,7 @@ struct sway_xwayland_view {
 	struct wl_listener set_title;
 	struct wl_listener set_class;
 	struct wl_listener set_role;
+	struct wl_listener set_startup_id;
 	struct wl_listener set_window_type;
 	struct wl_listener set_hints;
 	struct wl_listener set_decorations;
diff --git a/sway/commands/exec_always.c b/sway/commands/exec_always.c
index e432c463bc..59a076685a 100644
--- a/sway/commands/exec_always.c
+++ b/sway/commands/exec_always.c
@@ -32,11 +32,17 @@ static void export_xdga_token(struct launcher_ctx *ctx) {
 	setenv("XDG_ACTIVATION_TOKEN", token, 1);
 }
 
+static void export_startup_id(struct launcher_ctx *ctx) {
+	const char *token = launcher_ctx_get_name(ctx);
+	setenv("DESKTOP_STARTUP_ID", token, 1);
+}
+
 struct cmd_results *cmd_exec_process(int argc, char **argv) {
 	struct cmd_results *error = NULL;
 	char *cmd = NULL;
+	bool no_startup_id = false;
 	if (strcmp(argv[0], "--no-startup-id") == 0) {
-		sway_log(SWAY_INFO, "exec switch '--no-startup-id' not supported, ignored.");
+		no_startup_id = true;
 		--argc; ++argv;
 		if ((error = checkarg(argc, argv[-1], EXPECTED_AT_LEAST, 1))) {
 			return error;
@@ -72,6 +78,9 @@ struct cmd_results *cmd_exec_process(int argc, char **argv) {
 		if ((child = fork()) == 0) {
 			close(fd[1]);
 			export_xdga_token(ctx);
+			if (!no_startup_id) {
+				export_startup_id(ctx);
+			}
 			execlp("sh", "sh", "-c", cmd, (void *)NULL);
 			sway_log_errno(SWAY_ERROR, "execlp failed");
 			_exit(1);
diff --git a/sway/desktop/xwayland.c b/sway/desktop/xwayland.c
index 40288f9738..815233e8b9 100644
--- a/sway/desktop/xwayland.c
+++ b/sway/desktop/xwayland.c
@@ -5,6 +5,7 @@
 #include <wayland-server-core.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_xdg_activation_v1.h>
 #include <wlr/xwayland.h>
 #include "log.h"
 #include "sway/desktop.h"
@@ -15,6 +16,7 @@
 #include "sway/output.h"
 #include "sway/tree/arrange.h"
 #include "sway/tree/container.h"
+#include "sway/server.h"
 #include "sway/tree/view.h"
 #include "sway/tree/workspace.h"
 
@@ -448,6 +450,7 @@ static void handle_destroy(struct wl_listener *listener, void *data) {
 	wl_list_remove(&xwayland_view->set_title.link);
 	wl_list_remove(&xwayland_view->set_class.link);
 	wl_list_remove(&xwayland_view->set_role.link);
+	wl_list_remove(&xwayland_view->set_startup_id.link);
 	wl_list_remove(&xwayland_view->set_window_type.link);
 	wl_list_remove(&xwayland_view->set_hints.link);
 	wl_list_remove(&xwayland_view->set_decorations.link);
@@ -647,6 +650,27 @@ static void handle_set_role(struct wl_listener *listener, void *data) {
 	view_execute_criteria(view);
 }
 
+static void handle_set_startup_id(struct wl_listener *listener, void *data) {
+	struct sway_xwayland_view *xwayland_view =
+		wl_container_of(listener, xwayland_view, set_startup_id);
+	struct sway_view *view = &xwayland_view->view;
+	struct wlr_xwayland_surface *xsurface = view->wlr_xwayland_surface;
+	if (xsurface->startup_id == NULL) {
+		return;
+	}
+
+	struct wlr_xdg_activation_token_v1 *token =
+		wlr_xdg_activation_v1_find_token(
+				server.xdg_activation_v1, xsurface->startup_id);
+	if (token == NULL) {
+		// We don't support external launchers in X
+		return;
+	}
+
+	struct launcher_ctx *ctx = token->data;
+	view_assign_ctx(view, ctx);
+}
+
 static void handle_set_window_type(struct wl_listener *listener, void *data) {
 	struct sway_xwayland_view *xwayland_view =
 		wl_container_of(listener, xwayland_view, set_window_type);
@@ -731,6 +755,10 @@ struct sway_xwayland_view *create_xwayland_view(struct wlr_xwayland_surface *xsu
 	wl_signal_add(&xsurface->events.set_role, &xwayland_view->set_role);
 	xwayland_view->set_role.notify = handle_set_role;
 
+	wl_signal_add(&xsurface->events.set_startup_id,
+			&xwayland_view->set_startup_id);
+	xwayland_view->set_startup_id.notify = handle_set_startup_id;
+
 	wl_signal_add(&xsurface->events.set_window_type,
 			&xwayland_view->set_window_type);
 	xwayland_view->set_window_type.notify = handle_set_window_type;
